<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TypeScript学习</title>
      <link href="/2022/12/31/TypeScript%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/12/31/TypeScript%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-介绍"><a href="#TypeScript-介绍" class="headerlink" title="TypeScript 介绍"></a>TypeScript 介绍</h1><h2 id="TypeScript-是什么"><a href="#TypeScript-是什么" class="headerlink" title="TypeScript 是什么"></a>TypeScript 是什么</h2><p>TypeScript（简称：TS）是 JavaScript 的超集（JS 有的 TS 都有）。 TypeScript &#x3D; Type + JavaScript（在 JS 基础之上，为 JS 添加了类型支持）。 TypeScript 是微软开发的开源编程语言，可以在任何运行 JavaScript 的地方运行。</p><span id="more"></span><p><img src="/2022/12/31/TypeScript%E5%AD%A6%E4%B9%A0/image-20221231223701793.png" alt="image-20221231223701793"></p><h2 id="TypeScript-为什么要为-JS-添加类型支持？"><a href="#TypeScript-为什么要为-JS-添加类型支持？" class="headerlink" title="TypeScript 为什么要为 JS 添加类型支持？"></a>TypeScript 为什么要为 JS 添加类型支持？</h2><p>背景：JS 的类型系统存在“先天缺陷”，JS 代码中绝大部分错误都是类型错误（Uncaught TypeError）。<br>问题：增加了找 Bug、改 Bug 的时间，严重影响开发效率。<br>从编程语言的动静来区分，TypeScript 属于静态类型的编程语言，JS 属于动态类型的编程语言。<br>静态类型：编译期做类型检查； 动态类型：执行期做类型检查。<br>代码编译和代码执行的顺序：1 编译 2 执行。<br>对于 JS 来说：需要等到代码真正去执行的时候才能发现错误（晚）。<br>对于 TS 来说：在代码编译的时候（代码执行前）就可以发现错误（早）。<br>并且，配合 VSCode 等开发工具，TS 可以提前到在编写代码的同时就发现代码中的错误，减少找 Bug、改 Bug 时间。</p><h2 id="TypeScript-相比-JS-的优势"><a href="#TypeScript-相比-JS-的优势" class="headerlink" title="TypeScript 相比 JS 的优势"></a>TypeScript 相比 JS 的优势</h2><ol><li><p>更早（写代码的同时）发现错误，减少找 Bug、改 Bug 时间，提升开发效率。 </p></li><li><p>程序中任何位置的代码都有代码提示，随时随地的安全感，增强了开发体验。 </p></li><li><p>强大的类型系统提升了代码的可维护性，使得重构代码更加容易。 </p></li><li><p>支持最新的 ECMAScript 语法，优先体验最新的语法，让你走在前端技术的最前沿。 </p></li><li><p>TS 类型推断机制，不需要在代码中的每个地方都显示标注类型，让你在享受优势的同时，尽量降低了成本。</p></li></ol><p>除此之外，Vue 3 源码使用 TS 重写、Angular 默认支持 TS、React 与 TS 完美配合，TypeScript 已成为大中型前端 项目的首先编程语言。</p><h1 id="TypeScript-初体验"><a href="#TypeScript-初体验" class="headerlink" title="TypeScript 初体验"></a>TypeScript 初体验</h1><h2 id="安装编译-TS-的工具包"><a href="#安装编译-TS-的工具包" class="headerlink" title="安装编译 TS 的工具包"></a>安装编译 TS 的工具包</h2><p>问题：为什么要安装编译 TS 的工具包？<br>回答：Node.js&#x2F;浏览器，只认识 JS 代码，不认识 TS 代码。需要先将 TS 代码转化为 JS 代码，然后才能运行。<br>安装命令：npm i -g typescript。<br>typescript 包：用来编译 TS 代码的包，提供了 tsc 命令，实现了 TS -&gt; JS 的转化。<br>验证是否安装成功：tsc –v（查看 typescript 的版本）。</p><p><img src="/2022/12/31/TypeScript%E5%AD%A6%E4%B9%A0/image-20221231224044163.png" alt="image-20221231224044163"></p><h2 id="编译并运行-TS-代码"><a href="#编译并运行-TS-代码" class="headerlink" title="编译并运行 TS 代码"></a>编译并运行 TS 代码</h2><ol><li>创建 hello.ts 文件（注意：TS 文件的后缀名为 .ts）。</li><li>将 TS 编译为 JS：在终端中输入命令，tsc hello.ts（此时，在同级目录中会出现一个同名的 JS 文件）。</li><li>执行 JS 代码：在终端中输入命令，node hello.js。</li></ol><p><img src="/2022/12/31/TypeScript%E5%AD%A6%E4%B9%A0/image-20221231224144057.png" alt="image-20221231224144057"></p><p>说明：所有合法的 JS 代码都是 TS 代码，有 JS 基础只需要学习 TS 的类型即可。<br>注意：由 TS 编译生成的 JS 文件，代码中就没有类型信息了。</p><h2 id="简化运行-TS-的步骤"><a href="#简化运行-TS-的步骤" class="headerlink" title="简化运行 TS 的步骤"></a>简化运行 TS 的步骤</h2><p>问题描述：每次修改代码后，都要重复执行两个命令，才能运行 TS 代码，太繁琐。<br>简化方式：使用 ts-node 包，直接在 Node.js 中执行 TS 代码。<br>安装命令：npm i -g ts-node（ts-node 包提供了 ts-node 命令）。<br>使用方式：ts-node hello.ts。<br>解释：ts-node 命令在内部偷偷的将 TS -&gt; JS，然后，再运行 JS 代码。</p><h1 id="TypeScript-常用类型"><a href="#TypeScript-常用类型" class="headerlink" title="TypeScript 常用类型"></a>TypeScript 常用类型</h1><p>TypeScript 是 JS 的超集，TS 提供了 JS 的所有功能，并且额外的增加了：类型系统。<br>所有的 JS 代码都是 TS 代码。<br>JS 有类型（比如，number&#x2F;string 等），但是 JS 不会检查变量的类型是否发生变化。而 TS 会检查。<br>TypeScript 类型系统的主要优势：可以显示标记出代码中的意外行为，从而降低了发生错误的可能性。</p><ol><li>类型注解</li><li>常用基础类型</li></ol><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>示例代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure><p>说明：代码中的 : number 就是类型注解。<br>作用：为变量添加类型约束。比如，上述代码中，约定变量 age 的类型为 number（数值类型）。<br>解释：约定了什么类型，就只能给变量赋值该类型的值，否则，就会报错。</p><p><img src="/2022/12/31/TypeScript%E5%AD%A6%E4%B9%A0/image-20221231224410718.png" alt="image-20221231224410718"></p><h2 id="常用基础类型概述"><a href="#常用基础类型概述" class="headerlink" title="常用基础类型概述"></a>常用基础类型概述</h2><p>可以将 TS 中的常用基础类型细分为两类：1 JS 已有类型 2 TS 新增类型。</p><ol><li>JS 已有类型<br>原始类型：number&#x2F;string&#x2F;boolean&#x2F;null&#x2F;undefined&#x2F;symbol。<br>对象类型：object（包括，数组、对象、函数等对象）。</li><li>TS 新增类型<br>联合类型、自定义类型（类型别名）、接口、元组、字面量类型、枚举、void、any 等。</li></ol><h2 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h2><ol><li>原始类型：number&#x2F;string&#x2F;boolean&#x2F;null&#x2F;undefined&#x2F;symbol。<br>特点：简单。这些类型，完全按照 JS 中类型的名称来书写。</li></ol><p><img src="/2022/12/31/TypeScript%E5%AD%A6%E4%B9%A0/image-20221231224517709.png" alt="image-20221231224517709"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> TS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot学习</title>
      <link href="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><h4 id="使用Idea创建项目"><a href="#使用Idea创建项目" class="headerlink" title="使用Idea创建项目"></a>使用Idea创建项目</h4><p>•   1. 创建新模块，选择Spring Initializr，并配置模块相关基础信息</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image002.gif" alt="desc"></p><p>•   2. 选择当前模块需要使用的技术集</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image004.gif" alt="desc"></p><p>•   3. 开发控制器类</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image006.gif" alt="desc"></p><p>•   4. 运行自动生成的Application类</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image008.gif" alt="desc"></p><p>•   注意事项：</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image010.gif" alt="desc"></p><h4 id="使用springboot官网创建"><a href="#使用springboot官网创建" class="headerlink" title="使用springboot官网创建"></a>使用springboot官网创建</h4><p>•   基于SpringBoot官网创建项目，地址：<a href="https://start.spring.io/">https://start.spring.io/</a></p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image012.gif" alt="desc"></p><p>•   1. 打开SpringBoot官网，选择Quickstart Your Project</p><p>•   2. 创建工程，并保存项目</p><p>•   3. 解压项目，通过IDE导入项目</p><p>•   注意事项：springboot的官网是外国网站存在不能访问的可能</p><h4 id="使用阿里云创建项目"><a href="#使用阿里云创建项目" class="headerlink" title="使用阿里云创建项目"></a>使用阿里云创建项目</h4><p>•   创建模块，选择start来源为自定义URL，其他类似第一种创建方式</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image014.gif" alt="desc"></p><h4 id="手动创建项目"><a href="#手动创建项目" class="headerlink" title="手动创建项目"></a>手动创建项目</h4><p>•   1. 创建普通Maven工程</p><p>•   2. 继承spring-boot-starter-parent</p><p>•   3. 添加依赖spring-boot-starter-web</p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image016.gif" alt="desc"></p><p>•   4. 制作引导类Application</p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image018.gif" alt="desc"></p><h3 id="入门案例解析"><a href="#入门案例解析" class="headerlink" title="入门案例解析"></a>入门案例解析</h3><h4 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image020.gif" alt="desc"></p><p>•   1. 开发SpringBoot程序要继承spring-boot-starter-parent</p><p>•   2. spring-boot-starter-parent中定义了若干个依赖管理</p><p>•   3. 继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突</p><p>•   4. 继承parent的形式也可以采用引入依赖的形式实现效果</p><h4 id="starter"><a href="#starter" class="headerlink" title="starter"></a>starter</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image022.gif" alt="desc"></p><p>•   1. 开发SpringBoot程序需要导入坐标时通常导入对应的starter</p><p>•   2. 每个不同的starter根据功能不同，通常包含多个依赖坐标</p><p>•   3. 使用starter可以实现快速配置的效果，达到简化配置的目的</p><h4 id="引导类"><a href="#引导类" class="headerlink" title="引导类"></a>引导类</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image024.gif" alt="desc"></p><p>•   1. SpringBoot工程提供引导类用来启动程序</p><p>•   2. SpringBoot工程启动后创建并初始化Spring容器</p><h4 id="辅助功能-内嵌tomcat"><a href="#辅助功能-内嵌tomcat" class="headerlink" title="辅助功能(内嵌tomcat)"></a>辅助功能(内嵌tomcat)</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image026.gif" alt="desc"></p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image028.gif" alt="desc"></p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><h3 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h3><h4 id="属性配置方式"><a href="#属性配置方式" class="headerlink" title="属性配置方式"></a>属性配置方式</h4><p>•   SpringBoot默认配置文件application.properties，通过键值对配置对应属性</p><h4 id="基础配置案例"><a href="#基础配置案例" class="headerlink" title="基础配置案例"></a>基础配置案例</h4><p>•   修改服务器端口</p><p>•   server.port&#x3D;80</p><p>•   关闭运行日志图标（banner）</p><p>•   spring.main.banner-mode&#x3D;off</p><p>•   设置日志相关</p><p>•   logging.level.root&#x3D;debug</p><h4 id="SpringBoot内置属性查询"><a href="#SpringBoot内置属性查询" class="headerlink" title="SpringBoot内置属性查询"></a>SpringBoot内置属性查询</h4><p>•   <a href="https://springdoc.cn/spring-boot/">https://springdoc.cn/spring-boot/</a></p><h4 id="配置文件类型"><a href="#配置文件类型" class="headerlink" title="配置文件类型"></a>配置文件类型</h4><p>•   .properties</p><p>•   .yml（主流格式）</p><p>•   .yaml</p><h4 id="SpringBoot配置文件加载顺序"><a href="#SpringBoot配置文件加载顺序" class="headerlink" title="SpringBoot配置文件加载顺序"></a>SpringBoot配置文件加载顺序</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image030.gif" alt="desc"></p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image032.gif" alt="desc"></p><h4 id="配置文件提示信息消失处理"><a href="#配置文件提示信息消失处理" class="headerlink" title="配置文件提示信息消失处理"></a>配置文件提示信息消失处理</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image034.gif" alt="desc"></p><h3 id="yaml数据格式"><a href="#yaml数据格式" class="headerlink" title="yaml数据格式"></a>yaml数据格式</h3><h4 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image036.gif" alt="desc"></p><h4 id="yaml语法规则"><a href="#yaml语法规则" class="headerlink" title="yaml语法规则"></a>yaml语法规则</h4><p>•   基础概念</p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image038.gif" alt="desc"></p><p>•   字面值表示方式</p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image040.gif" alt="desc"></p><p>•   数组表示方式：在属性名书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔</p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image042.gif" alt="desc"></p><h4 id="yaml数据读取"><a href="#yaml数据读取" class="headerlink" title="yaml数据读取"></a>yaml数据读取</h4><p>•   使用@Value读取单个数据，属性名引用方式：${一级属性名.二级属性名……}</p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image044.gif" alt="desc"></p><p>•   数组用中括号加索引的方式</p><p>•   在配置文件中可以使用属性名引用方式引用属性</p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image046.gif" alt="desc"></p><p>•   属性值中如果出现转移字符，需要使用双引号包裹</p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image048.gif" alt="desc"></p><p>•   使用Environment对象封装全部配置信息</p><p>•   使用@Autowired自动装配数据到Environment对象中</p><p>•   自定义对象封装指定数据的作用</p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image050.gif" alt="desc"></p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image052.gif" alt="desc"></p><h2 id="整合第三方技术"><a href="#整合第三方技术" class="headerlink" title="整合第三方技术"></a>整合第三方技术</h2><h3 id="整合junit"><a href="#整合junit" class="headerlink" title="整合junit"></a>整合junit</h3><h4 id="SpringBoot整合JUnit"><a href="#SpringBoot整合JUnit" class="headerlink" title="SpringBoot整合JUnit"></a>SpringBoot整合JUnit</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image054.gif" alt="desc"></p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image056.gif" alt="desc"></p><h4 id="结合启动配置类整合JUnit"><a href="#结合启动配置类整合JUnit" class="headerlink" title="结合启动配置类整合JUnit"></a>结合启动配置类整合JUnit</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image058.gif" alt="desc"></p><h3 id="整合mybatis"><a href="#整合mybatis" class="headerlink" title="整合mybatis"></a>整合mybatis</h3><h4 id="1-创建新模块，选择Spring初始化，并配置模块相关基础信息"><a href="#1-创建新模块，选择Spring初始化，并配置模块相关基础信息" class="headerlink" title="1. 创建新模块，选择Spring初始化，并配置模块相关基础信息"></a>1. 创建新模块，选择Spring初始化，并配置模块相关基础信息</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image060.gif" alt="desc"></p><h4 id="2-选择当前模块需要使用的技术集（MyBatis、MySQL）"><a href="#2-选择当前模块需要使用的技术集（MyBatis、MySQL）" class="headerlink" title="2. 选择当前模块需要使用的技术集（MyBatis、MySQL）"></a>2. 选择当前模块需要使用的技术集（MyBatis、MySQL）</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image062.gif" alt="desc"></p><h4 id="3-设置数据源参数"><a href="#3-设置数据源参数" class="headerlink" title="3. 设置数据源参数"></a>3. 设置数据源参数</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image064.gif" alt="desc"></p><p>•   配置数据源时，密码为0开头的需要加双引号，如：”000000”</p><p>•   注意：Mysql驱动版本大于8.0时，需要在url连接串中配置时区</p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image066.gif" alt="desc"></p><h4 id="4-定义数据层接口与映射配置"><a href="#4-定义数据层接口与映射配置" class="headerlink" title="4. 定义数据层接口与映射配置"></a>4. 定义数据层接口与映射配置</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image068.gif" alt="desc"></p><p>•   数据库SQL映射需要添加@Mapper被容器识别到</p><h4 id="5-测试类中注入dao接口，测试功能"><a href="#5-测试类中注入dao接口，测试功能" class="headerlink" title="5. 测试类中注入dao接口，测试功能"></a>5. 测试类中注入dao接口，测试功能</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image070.gif" alt="desc"></p><h3 id="整合mybatis-plus"><a href="#整合mybatis-plus" class="headerlink" title="整合mybatis-plus"></a>整合mybatis-plus</h3><h4 id="1-手动添加SpringBoot整合MyBatis-Plus的坐标，可以通过mvnrepository获取"><a href="#1-手动添加SpringBoot整合MyBatis-Plus的坐标，可以通过mvnrepository获取" class="headerlink" title="1. 手动添加SpringBoot整合MyBatis-Plus的坐标，可以通过mvnrepository获取"></a>1. 手动添加SpringBoot整合MyBatis-Plus的坐标，可以通过mvnrepository获取</h4><p>•   由于springboot未收录mybatis-plus插件，需要指定Version</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image072.gif" alt="desc"></p><h4 id="2-定义数据层接口与映射配置，继承BaseMapper"><a href="#2-定义数据层接口与映射配置，继承BaseMapper" class="headerlink" title="2. 定义数据层接口与映射配置，继承BaseMapper"></a>2. 定义数据层接口与映射配置，继承BaseMapper</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image074.gif" alt="desc"></p><h4 id="3-其他同SpringBoot整合MyBatis"><a href="#3-其他同SpringBoot整合MyBatis" class="headerlink" title="3. 其他同SpringBoot整合MyBatis"></a>3. 其他同SpringBoot整合MyBatis</h4><h3 id="整合Druid"><a href="#整合Druid" class="headerlink" title="整合Druid"></a>整合Druid</h3><h4 id="1-导入Druid对应的starter"><a href="#1-导入Druid对应的starter" class="headerlink" title="1. 导入Druid对应的starter"></a>1. 导入Druid对应的starter</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image076.gif" alt="desc"></p><h4 id="2-变更Druid的配置方式"><a href="#2-变更Druid的配置方式" class="headerlink" title="2. 变更Druid的配置方式"></a>2. 变更Druid的配置方式</h4><p>•   推荐配置方式</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image078.gif" alt="desc"></p><p>•   默认配置方式</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image080.gif" alt="desc"></p><h2 id="SSMP整合案例"><a href="#SSMP整合案例" class="headerlink" title="SSMP整合案例"></a>SSMP整合案例</h2><h3 id="1-模块创建"><a href="#1-模块创建" class="headerlink" title="1. 模块创建"></a>1. 模块创建</h3><h4 id="1-创建项目-，构选Spring-Web-与-MySql坐标"><a href="#1-创建项目-，构选Spring-Web-与-MySql坐标" class="headerlink" title="1. 创建项目 ，构选Spring Web 与 MySql坐标"></a>1. 创建项目 ，构选Spring Web 与 MySql坐标</h4><h4 id="2-修改配置文件为yml格式"><a href="#2-修改配置文件为yml格式" class="headerlink" title="2. 修改配置文件为yml格式"></a>2. 修改配置文件为yml格式</h4><h4 id="3-设置端口为80方便访问"><a href="#3-设置端口为80方便访问" class="headerlink" title="3. 设置端口为80方便访问"></a>3. 设置端口为80方便访问</h4><h3 id="2-实体类开发"><a href="#2-实体类开发" class="headerlink" title="2. 实体类开发"></a>2. 实体类开发</h3><h4 id="1-使用lombok简化开发"><a href="#1-使用lombok简化开发" class="headerlink" title="1. 使用lombok简化开发"></a>1. 使用lombok简化开发</h4><p>•   导入lombok无需指定版本，由SpringBoot提供版本</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image082.gif" alt="desc"></p><p>•   给指定实体类添加@Data注解（为当前实体类在编译期设置对应的get&#x2F;set方法，toString方法，hashCode方法，equals方法等）</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image084.gif" alt="desc"></p><h3 id="3-数据层开发"><a href="#3-数据层开发" class="headerlink" title="3. 数据层开发"></a>3. 数据层开发</h3><h4 id="1-导入MyBatisPlus与Druid对应的starter"><a href="#1-导入MyBatisPlus与Druid对应的starter" class="headerlink" title="1. 导入MyBatisPlus与Druid对应的starter"></a>1. 导入MyBatisPlus与Druid对应的starter</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image086.gif" alt="desc"></p><h4 id="2-配置数据源与MyBatisPlus对应的基础配置（id生成策略使用数据库自增策略）"><a href="#2-配置数据源与MyBatisPlus对应的基础配置（id生成策略使用数据库自增策略）" class="headerlink" title="2. 配置数据源与MyBatisPlus对应的基础配置（id生成策略使用数据库自增策略）"></a>2. 配置数据源与MyBatisPlus对应的基础配置（id生成策略使用数据库自增策略）</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image088.gif" alt="desc"></p><h4 id="3-继承BaseMapper并指定泛型"><a href="#3-继承BaseMapper并指定泛型" class="headerlink" title="3. 继承BaseMapper并指定泛型"></a>3. 继承BaseMapper并指定泛型</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image090.gif" alt="desc"></p><h4 id="4-制作测试类测试结果"><a href="#4-制作测试类测试结果" class="headerlink" title="4. 制作测试类测试结果"></a>4. 制作测试类测试结果</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image092.gif" alt="desc"></p><h4 id="5-为方便开发可以开启MyBatisPlus日志"><a href="#5-为方便开发可以开启MyBatisPlus日志" class="headerlink" title="5. 为方便开发可以开启MyBatisPlus日志"></a>5. 为方便开发可以开启MyBatisPlus日志</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image094.gif" alt="desc"></p><h4 id="数据层开发——分页功能"><a href="#数据层开发——分页功能" class="headerlink" title="数据层开发——分页功能"></a>数据层开发——分页功能</h4><p>•   分页操作需要设定分页对象IPage</p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image096.gif" alt="desc"></p><p>•   IPage对象中封装了分页操作中的所有数据</p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image098.gif" alt="desc"></p><p>•   分页操作是在MyBatisPlus的常规操作基础上增强得到，内部是动态的拼写SQL语句，因此需要增强对应的功能，使用MyBatisPlus拦截器实现</p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image100.gif" alt="desc"></p><h4 id="使用QueryWrapper对象封装查询条件，推荐使用LambdaQueryWrapper对象，所有查询操作封装成方法调用"><a href="#使用QueryWrapper对象封装查询条件，推荐使用LambdaQueryWrapper对象，所有查询操作封装成方法调用" class="headerlink" title="使用QueryWrapper对象封装查询条件，推荐使用LambdaQueryWrapper对象，所有查询操作封装成方法调用"></a>使用QueryWrapper对象封装查询条件，推荐使用LambdaQueryWrapper对象，所有查询操作封装成方法调用</h4><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image102.gif" alt="desc"></p><p>•   支持动态拼写查询条件</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image104.gif" alt="desc"></p><h3 id="4-业务层开发"><a href="#4-业务层开发" class="headerlink" title="4. 业务层开发"></a>4. 业务层开发</h3><h4 id="普通形式开发"><a href="#普通形式开发" class="headerlink" title="普通形式开发"></a>普通形式开发</h4><p>•   接口定义</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image106.gif" alt="desc"></p><p>•   实现类定义</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image108.gif" alt="desc"></p><p>•   实现类定义</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image110.gif" alt="desc"></p><p>•   测试类定义</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image112.gif" alt="desc"></p><h4 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h4><p>•   快速方案方案</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image114.gif" alt="desc"></p><p>•   接口定义</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image116.gif" alt="desc"></p><p>•   实现类定义</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image118.gif" alt="desc"></p><p>•   实现类追加功能</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image120.gif" alt="desc"></p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image122.gif" alt="desc"></p><h3 id="5-表现层开发"><a href="#5-表现层开发" class="headerlink" title="5. 表现层开发"></a>5. 表现层开发</h3><h4 id="1-基于Restful制作表现层接口"><a href="#1-基于Restful制作表现层接口" class="headerlink" title="1. 基于Restful制作表现层接口"></a>1. 基于Restful制作表现层接口</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image124.gif" alt="desc"></p><h4 id="2-接收参数"><a href="#2-接收参数" class="headerlink" title="2. 接收参数"></a>2. 接收参数</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image126.gif" alt="desc"></p><h4 id="3-表现层消息一致性处理"><a href="#3-表现层消息一致性处理" class="headerlink" title="3. 表现层消息一致性处理"></a>3. 表现层消息一致性处理</h4><p>•   设计统一的返回值结果类型便于前端开发读取数据</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image128.gif" alt="desc"></p><p>•   设计表现层返回结果的模型类，用于后端与前端进行数据格式统一，也称为前后端数据协议</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image130.gif" alt="desc"></p><h4 id="4-业务消息一致性处理"><a href="#4-业务消息一致性处理" class="headerlink" title="4. 业务消息一致性处理"></a>4. 业务消息一致性处理</h4><p>•   后台代码BUG导致数据格式不统一性</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image132.gif" alt="desc"></p><p>•   对异常进行统一处理，出现异常后，返回指定信息</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image134.gif" alt="desc"></p><p>•   修改表现层返回结果的模型类，封装出现异常后对应的信息</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image136.gif" alt="desc"></p><h4 id="5-分页功能"><a href="#5-分页功能" class="headerlink" title="5. 分页功能"></a>5. 分页功能</h4><p>•   分页查询</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image138.gif" alt="desc"></p><h4 id="6-删除功能维护"><a href="#6-删除功能维护" class="headerlink" title="6. 删除功能维护"></a>6. 删除功能维护</h4><p>•   对查询结果进行校验，如果当前页码值大于最大页码值，使用最大页码值作为当前页码值重新查询</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image140.gif" alt="desc"></p><h1 id="开发实用篇"><a href="#开发实用篇" class="headerlink" title="开发实用篇"></a>开发实用篇</h1><h2 id="1-热部署"><a href="#1-热部署" class="headerlink" title="1. 热部署"></a>1. 热部署</h2><h3 id="1-手动启动热部署"><a href="#1-手动启动热部署" class="headerlink" title="1. 手动启动热部署"></a>1. 手动启动热部署</h3><h4 id="1-开启开发者工具"><a href="#1-开启开发者工具" class="headerlink" title="1. 开启开发者工具"></a>1. 开启开发者工具</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image142.gif" alt="desc"></p><h4 id="2-激活热部署：Ctrl-F9（构建快捷键）"><a href="#2-激活热部署：Ctrl-F9（构建快捷键）" class="headerlink" title="2. 激活热部署：Ctrl + F9（构建快捷键）"></a>2. 激活热部署：Ctrl + F9（构建快捷键）</h4><h4 id="3-关于热部署"><a href="#3-关于热部署" class="headerlink" title="3. 关于热部署"></a>3. 关于热部署</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image144.gif" alt="desc"></p><h3 id="2-自动启动热部署"><a href="#2-自动启动热部署" class="headerlink" title="2. 自动启动热部署"></a>2. 自动启动热部署</h3><h4 id="1-设置自动构建项目（设置里先设置）"><a href="#1-设置自动构建项目（设置里先设置）" class="headerlink" title="1. 设置自动构建项目（设置里先设置）"></a>1. 设置自动构建项目（设置里先设置）</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image146.gif" alt="desc"></p><h4 id="2-设置自动构建项目（修改注册表）"><a href="#2-设置自动构建项目（修改注册表）" class="headerlink" title="2. 设置自动构建项目（修改注册表）"></a>2. 设置自动构建项目（修改注册表）</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image148.gif" alt="desc"></p><h4 id="3-激活方式：Idea失去焦点5秒后启动热部署"><a href="#3-激活方式：Idea失去焦点5秒后启动热部署" class="headerlink" title="3. 激活方式：Idea失去焦点5秒后启动热部署"></a>3. 激活方式：Idea失去焦点5秒后启动热部署</h4><h4 id="注意：idea2022以上方法不适用。详情前往IDEA2022-1热部署网站查看"><a href="#注意：idea2022以上方法不适用。详情前往IDEA2022-1热部署网站查看" class="headerlink" title="注意：idea2022以上方法不适用。详情前往IDEA2022.1热部署网站查看"></a>注意：idea2022以上方法不适用。详情前往IDEA2022.1热部署网站查看</h4><h3 id="3-热部署范围配置"><a href="#3-热部署范围配置" class="headerlink" title="3. 热部署范围配置"></a>3. 热部署范围配置</h3><h4 id="1-默认不触发重启的目录列表"><a href="#1-默认不触发重启的目录列表" class="headerlink" title="1. 默认不触发重启的目录列表"></a>1. 默认不触发重启的目录列表</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image150.gif" alt="desc"></p><h4 id="2-自定义不参与重启排除项"><a href="#2-自定义不参与重启排除项" class="headerlink" title="2. 自定义不参与重启排除项"></a>2. 自定义不参与重启排除项</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image152.gif" alt="desc"></p><h3 id="4-关闭热部署"><a href="#4-关闭热部署" class="headerlink" title="4. 关闭热部署"></a>4. 关闭热部署</h3><h4 id="1-设置高优先级属性禁用热部署"><a href="#1-设置高优先级属性禁用热部署" class="headerlink" title="1. 设置高优先级属性禁用热部署"></a>1. 设置高优先级属性禁用热部署</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image154.gif" alt="desc"></p><h2 id="2-配置高级"><a href="#2-配置高级" class="headerlink" title="2. 配置高级"></a>2. 配置高级</h2><h3 id="1-ConfigurationProperties"><a href="#1-ConfigurationProperties" class="headerlink" title="1. @ConfigurationProperties"></a>1. @ConfigurationProperties</h3><h4 id="使用-ConfigurationProperties为第三方bean绑定属性"><a href="#使用-ConfigurationProperties为第三方bean绑定属性" class="headerlink" title="使用@ConfigurationProperties为第三方bean绑定属性"></a>使用@ConfigurationProperties为第三方bean绑定属性</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image156.gif" alt="desc"></p><h4 id="EnableConfigurationProperties注解可以将使用-ConfigurationProperties注解对应的类加入Spring容器管控"><a href="#EnableConfigurationProperties注解可以将使用-ConfigurationProperties注解对应的类加入Spring容器管控" class="headerlink" title="@EnableConfigurationProperties注解可以将使用@ConfigurationProperties注解对应的类加入Spring容器管控"></a>@EnableConfigurationProperties注解可以将使用@ConfigurationProperties注解对应的类加入Spring容器管控</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image158.gif" alt="desc"></p><h4 id="注意事项-EnableConfigurationProperties与-Component不能同时使用"><a href="#注意事项-EnableConfigurationProperties与-Component不能同时使用" class="headerlink" title="注意事项@EnableConfigurationProperties与@Component不能同时使用"></a>注意事项@EnableConfigurationProperties与@Component不能同时使用</h4><h4 id="解除使用-ConfigurationProperties注释警告（有时候会提示配置注解处理器没有配置，添加以下的坐标即可解决）"><a href="#解除使用-ConfigurationProperties注释警告（有时候会提示配置注解处理器没有配置，添加以下的坐标即可解决）" class="headerlink" title="解除使用@ConfigurationProperties注释警告（有时候会提示配置注解处理器没有配置，添加以下的坐标即可解决）"></a>解除使用@ConfigurationProperties注释警告（有时候会提示配置注解处理器没有配置，添加以下的坐标即可解决）</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image160.gif" alt="desc"></p><h3 id="2-宽松绑定-x2F-松散绑定"><a href="#2-宽松绑定-x2F-松散绑定" class="headerlink" title="2. 宽松绑定&#x2F;松散绑定"></a>2. 宽松绑定&#x2F;松散绑定</h3><h4 id="ConfigurationProperties绑定属性支持属性名宽松绑定"><a href="#ConfigurationProperties绑定属性支持属性名宽松绑定" class="headerlink" title="@ConfigurationProperties绑定属性支持属性名宽松绑定"></a>@ConfigurationProperties绑定属性支持属性名宽松绑定</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image162.gif" alt="desc"></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>•   宽松绑定不支持注解@Value引用单个属性的方式</p><p>•   绑定前缀名命名规范：仅能使用纯小写字母、数字、下划线作为合法的字符</p><h3 id="3-常量计量单位绑定"><a href="#3-常量计量单位绑定" class="headerlink" title="3. 常量计量单位绑定"></a>3. 常量计量单位绑定</h3><h4 id="SpringBoot支持JDK8提供的时间与空间计量单位"><a href="#SpringBoot支持JDK8提供的时间与空间计量单位" class="headerlink" title="SpringBoot支持JDK8提供的时间与空间计量单位"></a>SpringBoot支持JDK8提供的时间与空间计量单位</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image164.gif" alt="desc"></p><h4 id="JDK8支持的时间与空间计量单位"><a href="#JDK8支持的时间与空间计量单位" class="headerlink" title="JDK8支持的时间与空间计量单位"></a>JDK8支持的时间与空间计量单位</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image166.gif" alt="desc"></p><h3 id="4-数据校验"><a href="#4-数据校验" class="headerlink" title="4. 数据校验"></a>4. 数据校验</h3><h4 id="1-添加JSR303规范坐标与Hibernate校验框架对应坐标"><a href="#1-添加JSR303规范坐标与Hibernate校验框架对应坐标" class="headerlink" title="1. 添加JSR303规范坐标与Hibernate校验框架对应坐标"></a>1. 添加JSR303规范坐标与Hibernate校验框架对应坐标</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image168.gif" alt="desc"></p><h4 id="2-对Bean开启校验功能"><a href="#2-对Bean开启校验功能" class="headerlink" title="2. 对Bean开启校验功能"></a>2. 对Bean开启校验功能</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image170.gif" alt="desc"></p><h4 id="3-设置校验规则"><a href="#3-设置校验规则" class="headerlink" title="3. 设置校验规则"></a>3. 设置校验规则</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image172.gif" alt="desc"></p><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><h3 id="1-加载测试专用属性"><a href="#1-加载测试专用属性" class="headerlink" title="1. 加载测试专用属性"></a>1. 加载测试专用属性</h3><h4 id="1-在启动测试环境时可以通过properties参数设置测试环境专用的属性"><a href="#1-在启动测试环境时可以通过properties参数设置测试环境专用的属性" class="headerlink" title="1. 在启动测试环境时可以通过properties参数设置测试环境专用的属性"></a>1. 在启动测试环境时可以通过properties参数设置测试环境专用的属性</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image174.gif" alt="desc"></p><h4 id="2-在启动测试环境时可以通过args参数设置测试环境专用的传入参数"><a href="#2-在启动测试环境时可以通过args参数设置测试环境专用的传入参数" class="headerlink" title="2. 在启动测试环境时可以通过args参数设置测试环境专用的传入参数"></a>2. 在启动测试环境时可以通过args参数设置测试环境专用的传入参数</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image176.gif" alt="desc"></p><h3 id="2-加载测试专用配置"><a href="#2-加载测试专用配置" class="headerlink" title="2. 加载测试专用配置"></a>2. 加载测试专用配置</h3><h4 id="1-使用-Import注解加载当前测试类专用的配置"><a href="#1-使用-Import注解加载当前测试类专用的配置" class="headerlink" title="1. 使用@Import注解加载当前测试类专用的配置"></a>1. 使用@Import注解加载当前测试类专用的配置</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image178.gif" alt="desc"></p><h3 id="3-web环境模拟测试"><a href="#3-web环境模拟测试" class="headerlink" title="3. web环境模拟测试"></a>3. web环境模拟测试</h3><h4 id="1-模拟端口"><a href="#1-模拟端口" class="headerlink" title="1. 模拟端口"></a>1. 模拟端口</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image180.gif" alt="desc"></p><h4 id="2-虚拟请求测试"><a href="#2-虚拟请求测试" class="headerlink" title="2. 虚拟请求测试"></a>2. 虚拟请求测试</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image182.gif" alt="desc"></p><h4 id="3-虚拟请求状态匹配"><a href="#3-虚拟请求状态匹配" class="headerlink" title="3. 虚拟请求状态匹配"></a>3. 虚拟请求状态匹配</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image184.gif" alt="desc"></p><h4 id="4-虚拟请求响应体匹配"><a href="#4-虚拟请求响应体匹配" class="headerlink" title="4. 虚拟请求响应体匹配"></a>4. 虚拟请求响应体匹配</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image186.gif" alt="desc"></p><h4 id="5-虚拟请求响应体（json）匹配"><a href="#5-虚拟请求响应体（json）匹配" class="headerlink" title="5. 虚拟请求响应体（json）匹配"></a>5. 虚拟请求响应体（json）匹配</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image188.gif" alt="desc"></p><h4 id="6-虚拟请求响应头匹配"><a href="#6-虚拟请求响应头匹配" class="headerlink" title="6. 虚拟请求响应头匹配"></a>6. 虚拟请求响应头匹配</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image190.gif" alt="desc"></p><h3 id="4-数据层回滚测试"><a href="#4-数据层回滚测试" class="headerlink" title="4. 数据层回滚测试"></a>4. 数据层回滚测试</h3><h4 id="1-为测试用例添加事务，SpringBoot会对测试用例对应的事务提交操作进行回滚"><a href="#1-为测试用例添加事务，SpringBoot会对测试用例对应的事务提交操作进行回滚" class="headerlink" title="1. 为测试用例添加事务，SpringBoot会对测试用例对应的事务提交操作进行回滚"></a>1. 为测试用例添加事务，SpringBoot会对测试用例对应的事务提交操作进行回滚</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image192.gif" alt="desc"></p><h4 id="2-如果想在测试用例中提交事务，可以通过-Rollback注解设置"><a href="#2-如果想在测试用例中提交事务，可以通过-Rollback注解设置" class="headerlink" title="2. 如果想在测试用例中提交事务，可以通过@Rollback注解设置"></a>2. 如果想在测试用例中提交事务，可以通过@Rollback注解设置</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image194.gif" alt="desc"></p><h3 id="5-测试用例数据设定"><a href="#5-测试用例数据设定" class="headerlink" title="5. 测试用例数据设定"></a>5. 测试用例数据设定</h3><h4 id="1-测试用例数据通常采用随机值进行测试，使用SpringBoot提供的随机数为其赋值"><a href="#1-测试用例数据通常采用随机值进行测试，使用SpringBoot提供的随机数为其赋值" class="headerlink" title="1. 测试用例数据通常采用随机值进行测试，使用SpringBoot提供的随机数为其赋值"></a>1. 测试用例数据通常采用随机值进行测试，使用SpringBoot提供的随机数为其赋值</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image196.gif" alt="desc"></p><h2 id="4-数据层解决方案"><a href="#4-数据层解决方案" class="headerlink" title="4. 数据层解决方案"></a>4. 数据层解决方案</h2><h3 id="1-SQL"><a href="#1-SQL" class="headerlink" title="1. SQL"></a>1. SQL</h3><h4 id="1-数据源配置格式"><a href="#1-数据源配置格式" class="headerlink" title="1. 数据源配置格式"></a>1. 数据源配置格式</h4><p>•   格式一</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image198.gif" alt="desc"></p><p>•   格式二</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image200.gif" alt="desc"></p><h4 id="2-数据源配置"><a href="#2-数据源配置" class="headerlink" title="2. 数据源配置"></a>2. 数据源配置</h4><p>•   SpringBoot提供了3种内嵌的数据源对象供开发者选择</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image202.gif" alt="desc"></p><p>•   通用配置无法设置具体的数据源配置信息，仅提供基本的连接相关配置，如需配置，在下一级配置中设置具体设定</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image204.gif" alt="desc"></p><p>•   注意：HiKariCP是springboot默认配置的，如果使用另外两个，需要禁用掉HiKariCP</p><h4 id="3-持久化技术"><a href="#3-持久化技术" class="headerlink" title="3. 持久化技术"></a>3. 持久化技术</h4><p>•   内置持久化解决方案——JdbcTemplate</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image206.gif" alt="desc"></p><p>•   需要配置pom文件（mybatisplus默认内置此功能）</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image208.gif" alt="desc"></p><h4 id="3-内嵌数据库"><a href="#3-内嵌数据库" class="headerlink" title="3. 内嵌数据库"></a>3. 内嵌数据库</h4><p>•   SpringBoot提供了3种内嵌数据库供开发者选择，提高开发测试效率</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image210.gif" alt="desc"></p><p>•   H2</p><p>•   导入H2相关坐标</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image212.gif" alt="desc"></p><p>•   设置当前项目为web工程，并配置H2管理控制台参数</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image214.gif" alt="desc"></p><p>•   操作数据库（创建表）</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image216.gif" alt="desc"></p><p>•   设置访问数据源</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image218.gif" alt="desc"></p><p>•   H2数据库控制台仅用于开发阶段，线上项目请务必关闭控制台功能</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image220.gif" alt="desc"></p><p>•   SpringBoot可以根据url地址自动识别数据库种类，在保障驱动类存在的情况下，可以省略配置</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image222.gif" alt="desc"></p><h3 id="2-NOSQL"><a href="#2-NOSQL" class="headerlink" title="2. NOSQL"></a>2. NOSQL</h3><h4 id="1-Redis"><a href="#1-Redis" class="headerlink" title="1. Redis"></a>1. Redis</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image224.gif" alt="desc"></p><p>•   导入SpringBoot整合Redis坐标</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image226.gif" alt="desc"></p><p>•   配置Redis（采用默认配置）</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image228.gif" alt="desc"></p><p>•   RedisTemplate提供操作各种数据存储类型的接口API</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image230.gif" alt="desc"></p><p>•   客户端：RedisTemplate</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image232.gif" alt="desc"></p><p>•   客户端：RedisTemplate以对象作为key和value，内部对数据进行序列化</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image234.gif" alt="desc"></p><p>•   客户端：StringRedisTemplate以字符串作为key和value，与Redis客户端操作等效</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image236.gif" alt="desc"></p><p>•   客户端选择：jedis</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image238.gif" alt="desc"></p><p>•   配置客户端</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image240.gif" alt="desc"></p><p>•   配置客户端专用属性</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image242.gif" alt="desc"></p><p>•   lettcus与jedis区别</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image244.gif" alt="desc"></p><h4 id="2-Mongodb"><a href="#2-Mongodb" class="headerlink" title="2. Mongodb"></a>2. Mongodb</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image246.gif" alt="desc"></p><p>•   应用场景</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image248.gif" alt="desc"></p><p>•   安装启动</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image250.gif" alt="desc"></p><p>•   可视化客户端——Robo 3T</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image252.gif" alt="desc"></p><p>•   基础CURD</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image254.gif" alt="desc"></p><p>•   基础查询</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image256.gif" alt="desc"></p><p>•   SpringBoot整合Mongodb</p><p>•   导入Mongodb驱动</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image258.gif" alt="desc"></p><p>•   配置客户端</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image260.gif" alt="desc"></p><p>•   客户端读写Mongodb</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image262.gif" alt="desc"></p><h4 id="3-ElasticSearch（ES）"><a href="#3-ElasticSearch（ES）" class="headerlink" title="3. ElasticSearch（ES）"></a>3. ElasticSearch（ES）</h4><p>•   Elasticsearch是一个分布式全文搜索引擎</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image264.gif" alt="desc"></p><p>•   ES下载与安装</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image266.gif" alt="desc"></p><p>•   创建&#x2F;查询&#x2F;删除索引</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image268.gif" alt="desc"></p><p>•   IK分词器下载：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p><p>•   创建索引并指定规则</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image270.gif" alt="desc"></p><p>•   文档操作</p><p>•   创建文档</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image272.gif" alt="desc"></p><p>•   查询文档</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image274.gif" alt="desc"></p><p>•   条件查询</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image276.gif" alt="desc"></p><p>•   删除文档</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image278.gif" alt="desc"></p><p>•   修改文档（全量修改）</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image280.gif" alt="desc"></p><p>•   修改文档（部分修改）</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image282.gif" alt="desc"></p><p>•   整合ES</p><p>•   配置</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image284.gif" alt="desc"></p><p>•   SpringBoot平台并没有跟随ES的更新速度进行同步更新，ES提供了High Level Client操作ES</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image286.gif" alt="desc"></p><p>•   客户端</p><p>•   初始化</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image288.gif" alt="desc"></p><p>•   改进</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image290.gif" alt="desc"></p><p>•   测试</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image292.gif" alt="desc"></p><p>•   创建索引</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image294.gif" alt="desc"></p><p>•   添加文档</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image296.gif" alt="desc"></p><p>•   批量添加文档</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image298.gif" alt="desc"></p><p>•   按id查询文档</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image300.gif" alt="desc"></p><p>•   按条件查询文档</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image302.gif" alt="desc"></p><h2 id="5-整合第三方技术"><a href="#5-整合第三方技术" class="headerlink" title="5. 整合第三方技术"></a>5. 整合第三方技术</h2><h3 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1. 缓存"></a>1. 缓存</h3><h4 id="缓存作用"><a href="#缓存作用" class="headerlink" title="缓存作用"></a>缓存作用</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image304.gif" alt="desc"></p><h4 id="SpringBoot启用缓存的方式"><a href="#SpringBoot启用缓存的方式" class="headerlink" title="SpringBoot启用缓存的方式"></a>SpringBoot启用缓存的方式</h4><p>•   导入缓存技术对应的starter</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image306.gif" alt="desc"></p><p>•   启用缓存</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image308.gif" alt="desc"></p><p>•   设置当前操作的结果数据进入缓存</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image310.gif" alt="desc"></p><h4 id="SpringBoot提供的缓存方案"><a href="#SpringBoot提供的缓存方案" class="headerlink" title="SpringBoot提供的缓存方案"></a>SpringBoot提供的缓存方案</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image312.gif" alt="desc"></p><h4 id="缓存使用案例—手机验证码"><a href="#缓存使用案例—手机验证码" class="headerlink" title="缓存使用案例—手机验证码"></a>缓存使用案例—手机验证码</h4><p>•   开启验证码</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image314.gif" alt="desc"></p><p>•   业务层接口</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image316.gif" alt="desc"></p><p>•   业务层设置获取验证码操作，并存储缓存，手机号为key，验证码为value</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image318.gif" alt="desc"></p><p>•   业务层设置校验验证码操作，校验码通过缓存读取，返回校验结果</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image320.gif" alt="desc"></p><h4 id="缓存供应商变更：Ehcache"><a href="#缓存供应商变更：Ehcache" class="headerlink" title="缓存供应商变更：Ehcache"></a>缓存供应商变更：Ehcache</h4><p>•   加入Ehcache坐标</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image322.gif" alt="desc"></p><p>•   缓存设定为使用Ehcache</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image324.gif" alt="desc"></p><p>•   提供ehcache配置文件ehcache.xml</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image326.gif" alt="desc"></p><h4 id="缓存供应商变更：Redis"><a href="#缓存供应商变更：Redis" class="headerlink" title="缓存供应商变更：Redis"></a>缓存供应商变更：Redis</h4><p>•   加入Redis坐标（缓存供应商实现）</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image328.gif" alt="desc"></p><p>•   配置Redis服务器，缓存设定为使用Redis</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image330.gif" alt="desc"></p><p>•   设置Redis相关配置</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image332.gif" alt="desc"></p><h4 id="缓存供应商变更-memcached"><a href="#缓存供应商变更-memcached" class="headerlink" title="缓存供应商变更:memcached"></a>缓存供应商变更:memcached</h4><p>•   下载memcached地址：<a href="https://www.runoob.com/memcached/window-install-memcached.html">https://www.runoob.com/memcached/window-install-memcached.html</a></p><p>•   安装memcached</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image334.gif" alt="desc"></p><p>•   运行memcached</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image336.gif" alt="desc"></p><p>•   memcached客户端选择</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image338.gif" alt="desc"></p><p>•   加入Xmemcache坐标（缓存供应商实现）</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image340.gif" alt="desc"></p><p>•   配置memcached服务器必要属性</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image342.gif" alt="desc"></p><p>•   创建读取属性配置信息类，加载配置</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image344.gif" alt="desc"></p><p>•   创建客户端配置类</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image346.gif" alt="desc"></p><p>•   配置memcached属性</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image348.gif" alt="desc"></p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image350.gif" alt="desc"></p><h4 id="缓存供应商变更-jetcache"><a href="#缓存供应商变更-jetcache" class="headerlink" title="缓存供应商变更:jetcache"></a>缓存供应商变更:jetcache</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image352.gif" alt="desc"></p><p>•   加入jetcache坐标</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image354.gif" alt="desc"></p><p>•   配置远程缓存必要属性</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image356.gif" alt="desc"></p><p>•   配置本地缓存必要属性</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image358.gif" alt="desc"></p><p>•   配置范例</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image360.gif" alt="desc"></p><p>•   配置属性说明</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image362.gif" alt="desc"></p><p>•   开启jetcache注解支持</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image364.gif" alt="desc"></p><p>•   声明缓存对象</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image366.gif" alt="desc"></p><p>•   操作缓存</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image368.gif" alt="desc"></p><p>•   启用方法注解</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image370.gif" alt="desc"></p><p>•   使用方法注解操作缓存</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image372.gif" alt="desc"></p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image374.gif" alt="desc"></p><p>•   缓存对象必须保障可序列化</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image376.gif" alt="desc"></p><p>•   查看缓存统计报告</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image378.gif" alt="desc"></p><h4 id="缓存供应商变更-j2cache"><a href="#缓存供应商变更-j2cache" class="headerlink" title="缓存供应商变更:j2cache"></a>缓存供应商变更:j2cache</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image380.gif" alt="desc"></p><p>•   加入j2cache坐标，加入整合缓存的坐标</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image382.gif" alt="desc"></p><p>•   配置使用j2cache（application.yml）</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image384.gif" alt="desc"></p><p>•   配置一级缓存与二级缓存以及一级缓存数据到二级缓存的发送方式（j2cache.properties）</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image386.gif" alt="desc"></p><p>•   设置使用缓存</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image388.gif" alt="desc"></p><p>•   </p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image390.gif" alt="desc"></p><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2. 任务"></a>2. 任务</h3><h4 id="SpringBoot整合Quartz"><a href="#SpringBoot整合Quartz" class="headerlink" title="SpringBoot整合Quartz"></a>SpringBoot整合Quartz</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image392.gif" alt="desc"></p><p>•   导入SpringBoot整合quartz的坐标</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image394.gif" alt="desc"></p><p>•   定义具体要执行的任务，继承QuartzJobBean</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image396.gif" alt="desc"></p><p>•   定义工作明细与触发器，并绑定对应关系</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image398.gif" alt="desc"></p><h4 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring Task"></a>Spring Task</h4><p>•   开启定时任务功能</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image400.gif" alt="desc"></p><p>•   设置定时执行的任务，并设定执行周期</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image402.gif" alt="desc"></p><p>•   定时任务相关配置</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image404.gif" alt="desc"></p><h3 id="3-邮件"><a href="#3-邮件" class="headerlink" title="3. 邮件"></a>3. 邮件</h3><h4 id="SpringBoot整合JavaMail"><a href="#SpringBoot整合JavaMail" class="headerlink" title="SpringBoot整合JavaMail"></a>SpringBoot整合JavaMail</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image406.gif" alt="desc"></p><p>•   导入SpringBoot整合JavaMail的坐标</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image408.gif" alt="desc"></p><p>•   配置JavaMail</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image410.gif" alt="desc"></p><p>•   配置发送信息文本</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image412.gif" alt="desc"></p><p>•   发送邮件</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image414.gif" alt="desc"></p><p>•   附件与HTML文本支持</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image416.gif" alt="desc"></p><h3 id="4-消息"><a href="#4-消息" class="headerlink" title="4. 消息"></a>4. 消息</h3><h4 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image418.gif" alt="desc"></p><h4 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image420.gif" alt="desc"></p><h4 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image422.gif" alt="desc"></p><h4 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h4><p>•   下载地址安装：解压缩</p><p>•   开启服务</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image424.gif" alt="desc"></p><p>•   SpringBoot整合ActiveMQ</p><p>•   导入SpringBoot整合ActiveMQ坐标</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image426.gif" alt="desc"></p><p>•   配置ActiveMQ（采用默认配置）</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image428.gif" alt="desc"></p><p>•   生产与消费消息（使用默认消息存储队列）</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image430.gif" alt="desc"></p><p>•   生产与消费消息（指定消息存储队列）</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image432.gif" alt="desc"></p><p>•   使用消息监听器对消息队列监听</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image434.gif" alt="desc"></p><p>•   流程性业务消息消费完转入下一个消息队列</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image436.gif" alt="desc"></p><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>•   RabbitMQ基于Erlang语言编写，需要安装Erlang</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image438.gif" alt="desc"></p><p>•   RabbitMQ下载安装：傻瓜式安装</p><p>•   服务</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image440.gif" alt="desc"></p><p>•   服务管理可视化（插件形式）</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image442.gif" alt="desc"></p><p>•   SpringBoot整合RabbitMQ</p><p>•   导入SpringBoot整合RabbitMQ坐标</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image444.gif" alt="desc"></p><p>•   配置RabbitMQ （采用默认配置）</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image446.gif" alt="desc"></p><p>•   定义消息队列(direct)</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image448.gif" alt="desc"></p><p>•   生产与消费消息(direct)</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image450.gif" alt="desc"></p><p>•   使用消息监听器对消息队列监听(direct)</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image452.gif" alt="desc"></p><p>•   使用多消息监听器对消息队列监听进行消息轮循处理(direct)</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image454.gif" alt="desc"></p><p>•   定义消息队列(topic)</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image456.gif" alt="desc"></p><p>•   绑定键匹配规则</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image458.gif" alt="desc"></p><p>•   生产与消费消息(topic)</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image460.gif" alt="desc"></p><p>•   使用消息监听器对消息队列监听(topic)</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image462.gif" alt="desc"></p><h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image464.gif" alt="desc"></p><p>•   命名服务器与broker</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image466.gif" alt="desc"></p><p>•   启动服务</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image468.gif" alt="desc"></p><p>•   测试服务</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image470.gif" alt="desc"></p><p>•   Springboot整合RocketMQ</p><p>•   导入SpringBoot整合RocketMQ坐标</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image472.gif" alt="desc"></p><p>•   配置RocketMQ （采用默认配置）</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image474.gif" alt="desc"></p><p>•   生产消息</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image476.gif" alt="desc"></p><p>•   生产异步消息</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image478.gif" alt="desc"></p><p>•   使用消息监听器对消息队列监听</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image480.gif" alt="desc"></p><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image482.gif" alt="desc"></p><p>•   启动</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image484.gif" alt="desc"></p><p>•   topic</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image486.gif" alt="desc"></p><p>•   测试</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image488.gif" alt="desc"></p><p>•   springboot整合kafka</p><p>•   导入SpringBoot整合Kafka坐标</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image490.gif" alt="desc"></p><p>•   配置Kafka （采用默认配置）</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image492.gif" alt="desc"></p><p>•   生产消息</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image494.gif" alt="desc"></p><p>•   使用消息监听器对消息队列监听</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image496.gif" alt="desc"></p><h2 id="6-监控"><a href="#6-监控" class="headerlink" title="6. 监控"></a>6. 监控</h2><h3 id="监控的意义"><a href="#监控的意义" class="headerlink" title="监控的意义"></a>监控的意义</h3><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image498.gif" alt="desc"></p><h4 id="监控的实施方式"><a href="#监控的实施方式" class="headerlink" title="监控的实施方式"></a>监控的实施方式</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image500.gif" alt="desc"></p><h3 id="可视化监控平台"><a href="#可视化监控平台" class="headerlink" title="可视化监控平台"></a>可视化监控平台</h3><h4 id="Spring-Boot-Admin，开源社区项目，用于管理和监控SpringBoot应用程序。-客户端注册到服务端后，通过HTTP请求方式，服务端定期从客户端获取对应的信息，并通过UI界面展示对应信息。"><a href="#Spring-Boot-Admin，开源社区项目，用于管理和监控SpringBoot应用程序。-客户端注册到服务端后，通过HTTP请求方式，服务端定期从客户端获取对应的信息，并通过UI界面展示对应信息。" class="headerlink" title="Spring Boot Admin，开源社区项目，用于管理和监控SpringBoot应用程序。 客户端注册到服务端后，通过HTTP请求方式，服务端定期从客户端获取对应的信息，并通过UI界面展示对应信息。"></a>Spring Boot Admin，开源社区项目，用于管理和监控SpringBoot应用程序。 客户端注册到服务端后，通过HTTP请求方式，服务端定期从客户端获取对应的信息，并通过UI界面展示对应信息。</h4><p>•   Admin服务端</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image502.gif" alt="desc"></p><p>•   Admin客户端</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image504.gif" alt="desc"></p><p>•   Admin服务端配置</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image506.gif" alt="desc"></p><p>•   设置启用Spring-Admin</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image508.gif" alt="desc"></p><p>•   Admin客户端配置</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image510.gif" alt="desc"></p><p>•   启动预览图</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image512.gif" alt="desc"></p><h3 id="监控原理"><a href="#监控原理" class="headerlink" title="监控原理"></a>监控原理</h3><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image514.gif" alt="desc"></p><h4 id="监控端点1"><a href="#监控端点1" class="headerlink" title="监控端点1"></a>监控端点1</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image516.gif" alt="desc"></p><h4 id="监控端点2"><a href="#监控端点2" class="headerlink" title="监控端点2"></a>监控端点2</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image518.gif" alt="desc"></p><h4 id="Web程序专用端点"><a href="#Web程序专用端点" class="headerlink" title="Web程序专用端点"></a>Web程序专用端点</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image520.gif" alt="desc"></p><h4 id="启用指定端点"><a href="#启用指定端点" class="headerlink" title="启用指定端点"></a>启用指定端点</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image522.gif" alt="desc"></p><h4 id="启用所有端点"><a href="#启用所有端点" class="headerlink" title="启用所有端点"></a>启用所有端点</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image524.gif" alt="desc"></p><h4 id="暴露端点功能"><a href="#暴露端点功能" class="headerlink" title="暴露端点功能"></a>暴露端点功能</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image526.gif" alt="desc"></p><h4 id="JMX和web端点差异1"><a href="#JMX和web端点差异1" class="headerlink" title="JMX和web端点差异1"></a>JMX和web端点差异1</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image528.gif" alt="desc"></p><h4 id="JMX和web端点差异2"><a href="#JMX和web端点差异2" class="headerlink" title="JMX和web端点差异2"></a>JMX和web端点差异2</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image530.gif" alt="desc"></p><h3 id="自定义监控指标"><a href="#自定义监控指标" class="headerlink" title="自定义监控指标"></a>自定义监控指标</h3><h4 id="为info端点添加自定义指标配置方式"><a href="#为info端点添加自定义指标配置方式" class="headerlink" title="为info端点添加自定义指标配置方式"></a>为info端点添加自定义指标配置方式</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image532.gif" alt="desc"></p><h4 id="为info端点添加自定义指标代码方式"><a href="#为info端点添加自定义指标代码方式" class="headerlink" title="为info端点添加自定义指标代码方式"></a>为info端点添加自定义指标代码方式</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image534.gif" alt="desc"></p><h4 id="为Health端点添加自定义指标"><a href="#为Health端点添加自定义指标" class="headerlink" title="为Health端点添加自定义指标"></a>为Health端点添加自定义指标</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image536.gif" alt="desc"></p><h4 id="为Metrics端点添加自定义指标"><a href="#为Metrics端点添加自定义指标" class="headerlink" title="为Metrics端点添加自定义指标"></a>为Metrics端点添加自定义指标</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image538.gif" alt="desc"></p><h4 id="自定义端点"><a href="#自定义端点" class="headerlink" title="自定义端点"></a>自定义端点</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image540.gif" alt="desc"></p><h1 id="运维实用篇"><a href="#运维实用篇" class="headerlink" title="运维实用篇"></a>运维实用篇</h1><h2 id="打包与运行"><a href="#打包与运行" class="headerlink" title="打包与运行"></a>打包与运行</h2><h3 id="windows版"><a href="#windows版" class="headerlink" title="windows版"></a>windows版</h3><h4 id="SpringBoot项目快速启动"><a href="#SpringBoot项目快速启动" class="headerlink" title="SpringBoot项目快速启动"></a>SpringBoot项目快速启动</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image542.gif" alt="desc"></p><h4 id="注意事项-（不使用maven插件打包运行时会出现-jar中没有出现主清单属性）"><a href="#注意事项-（不使用maven插件打包运行时会出现-jar中没有出现主清单属性）" class="headerlink" title="注意事项 （不使用maven插件打包运行时会出现***.jar中没有出现主清单属性）"></a>注意事项 （不使用maven插件打包运行时会出现***.jar中没有出现主清单属性）</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image544.gif" alt="desc"></p><h4 id="可执行jar包目录结构"><a href="#可执行jar包目录结构" class="headerlink" title="可执行jar包目录结构"></a>可执行jar包目录结构</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image546.gif" alt="desc"></p><h4 id="jar包描述文件（MANIFEST-MF）"><a href="#jar包描述文件（MANIFEST-MF）" class="headerlink" title="jar包描述文件（MANIFEST.MF）"></a>jar包描述文件（MANIFEST.MF）</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image548.gif" alt="desc"></p><h4 id="命令行启动常见问题及解决方案"><a href="#命令行启动常见问题及解决方案" class="headerlink" title="命令行启动常见问题及解决方案"></a>命令行启动常见问题及解决方案</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image550.gif" alt="desc"></p><h3 id="Linux版"><a href="#Linux版" class="headerlink" title="Linux版"></a>Linux版</h3><h4 id><a href="#" class="headerlink" title></a></h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image552.gif" alt="desc"></p><h4 id="-1"><a href="#-1" class="headerlink" title></a></h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image554.gif" alt="desc"></p><h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image556.gif" alt="desc"></p><h2 id="配置高级"><a href="#配置高级" class="headerlink" title="配置高级"></a>配置高级</h2><h3 id="临时属性设置"><a href="#临时属性设置" class="headerlink" title="临时属性设置"></a>临时属性设置</h3><h4 id="-3"><a href="#-3" class="headerlink" title></a></h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image558.gif" alt="desc"></p><h4 id="-4"><a href="#-4" class="headerlink" title></a></h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image560.gif" alt="desc"></p><h4 id="带属性启动SpringBoot程序，为程序添加运行属性"><a href="#带属性启动SpringBoot程序，为程序添加运行属性" class="headerlink" title="带属性启动SpringBoot程序，为程序添加运行属性"></a>带属性启动SpringBoot程序，为程序添加运行属性</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image562.gif" alt="desc"></p><h4 id="编程方式携带参数启动"><a href="#编程方式携带参数启动" class="headerlink" title="编程方式携带参数启动"></a>编程方式携带参数启动</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image564.gif" alt="desc"></p><h3 id="配置文件分类"><a href="#配置文件分类" class="headerlink" title="配置文件分类"></a>配置文件分类</h3><h4 id="1-SpringBoot中4级配置文件"><a href="#1-SpringBoot中4级配置文件" class="headerlink" title="1. SpringBoot中4级配置文件"></a>1. SpringBoot中4级配置文件</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image566.gif" alt="desc"></p><h4 id="2-作用："><a href="#2-作用：" class="headerlink" title="2. 作用："></a>2. 作用：</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image568.gif" alt="desc"></p><h4 id="3-配置文件分为4种"><a href="#3-配置文件分为4种" class="headerlink" title="3. 配置文件分为4种"></a>3. 配置文件分为4种</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image570.gif" alt="desc"></p><h4 id="4-多层级配置文件间的属性采用叠加并覆盖的形式作用于程序"><a href="#4-多层级配置文件间的属性采用叠加并覆盖的形式作用于程序" class="headerlink" title="4. 多层级配置文件间的属性采用叠加并覆盖的形式作用于程序"></a>4. 多层级配置文件间的属性采用叠加并覆盖的形式作用于程序</h4><h3 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h3><h4 id="通过启动参数加载配置文件（无需书写配置文件扩展名，properties与yml文件格式均支持"><a href="#通过启动参数加载配置文件（无需书写配置文件扩展名，properties与yml文件格式均支持" class="headerlink" title="通过启动参数加载配置文件（无需书写配置文件扩展名，properties与yml文件格式均支持)"></a>通过启动参数加载配置文件（无需书写配置文件扩展名，properties与yml文件格式均支持)</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image572.gif" alt="desc"></p><h4 id="通过启动参数加载指定文件路径下的配置文件"><a href="#通过启动参数加载指定文件路径下的配置文件" class="headerlink" title="通过启动参数加载指定文件路径下的配置文件"></a>通过启动参数加载指定文件路径下的配置文件</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image574.gif" alt="desc"></p><h4 id="通过启动参数加载指定文件路径下的配置文件时可以加载多个配置"><a href="#通过启动参数加载指定文件路径下的配置文件时可以加载多个配置" class="headerlink" title="通过启动参数加载指定文件路径下的配置文件时可以加载多个配置"></a>通过启动参数加载指定文件路径下的配置文件时可以加载多个配置</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image576.gif" alt="desc"></p><h4 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image578.gif" alt="desc"></p><h2 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h2><h3 id="多环境开发（YAML版）"><a href="#多环境开发（YAML版）" class="headerlink" title="多环境开发（YAML版）"></a>多环境开发（YAML版）</h3><h4 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h4><p><img src="file:///C:/Users/hyace/AppData/Local/Temp/msohtmlclip1/01/clip_image580.gif" alt="desc"></p><h4 id="新版配置"><a href="#新版配置" class="headerlink" title="新版配置"></a>新版配置</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image582.gif" alt="desc"></p><h4 id="多配置文件格式"><a href="#多配置文件格式" class="headerlink" title="多配置文件格式"></a>多配置文件格式</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image584.gif" alt="desc"></p><h4 id="多环境开发配置文件书写技巧"><a href="#多环境开发配置文件书写技巧" class="headerlink" title="多环境开发配置文件书写技巧"></a>多环境开发配置文件书写技巧</h4><p>•   一</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image586.gif" alt="desc"></p><p>•   二</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image588.gif" alt="desc"></p><p>•   二</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image590.gif" alt="desc"></p><p>•   注意事项：当主环境dev与其他环境有相同属性时，主环境属性生效；其他环境中有相同属性时，最后加载的环境属性生效</p><h3 id="多环境开发（Properties版）"><a href="#多环境开发（Properties版）" class="headerlink" title="多环境开发（Properties版）"></a>多环境开发（Properties版）</h3><h4 id="多配置文件格式-1"><a href="#多配置文件格式-1" class="headerlink" title="多配置文件格式"></a>多配置文件格式</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image592.gif" alt="desc"></p><h4 id="properties文件多环境配置仅支持多文件格式"><a href="#properties文件多环境配置仅支持多文件格式" class="headerlink" title="properties文件多环境配置仅支持多文件格式"></a>properties文件多环境配置仅支持多文件格式</h4><h3 id="多环境开发控制"><a href="#多环境开发控制" class="headerlink" title="多环境开发控制"></a>多环境开发控制</h3><h4 id="Maven与SpringBoot多环境兼容"><a href="#Maven与SpringBoot多环境兼容" class="headerlink" title="Maven与SpringBoot多环境兼容"></a>Maven与SpringBoot多环境兼容</h4><p>•   1. Maven中设置多环境属性</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image594.gif" alt="desc"></p><p>•   2. SpringBoot中引用Maven属性</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image596.gif" alt="desc"></p><p>•   3. 执行Maven打包指令，并在生成的boot打包文件.jar文件中查看对应信息</p><h2 id="4-日志"><a href="#4-日志" class="headerlink" title="4. 日志"></a>4. 日志</h2><h3 id="1-日志基础"><a href="#1-日志基础" class="headerlink" title="1. 日志基础"></a>1. 日志基础</h3><h4 id="日志作用"><a href="#日志作用" class="headerlink" title="日志作用"></a>日志作用</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image598.gif" alt="desc"></p><h4 id="添加日志记录操作"><a href="#添加日志记录操作" class="headerlink" title="添加日志记录操作"></a>添加日志记录操作</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image600.gif" alt="desc"></p><h4 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image602.gif" alt="desc"></p><h4 id="设置日志输出级别"><a href="#设置日志输出级别" class="headerlink" title="设置日志输出级别"></a>设置日志输出级别</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image604.gif" alt="desc"></p><h4 id="设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别"><a href="#设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别" class="headerlink" title="设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别"></a>设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image606.gif" alt="desc"></p><h4 id="使用lombok提供的注解-Slf4j简化开发，减少日志对象的声明操作"><a href="#使用lombok提供的注解-Slf4j简化开发，减少日志对象的声明操作" class="headerlink" title="使用lombok提供的注解@Slf4j简化开发，减少日志对象的声明操作"></a>使用lombok提供的注解@Slf4j简化开发，减少日志对象的声明操作</h4><h3 id="2-日志输出格式控制"><a href="#2-日志输出格式控制" class="headerlink" title="2. 日志输出格式控制"></a>2. 日志输出格式控制</h3><h4 id="设置日志输出格"><a href="#设置日志输出格" class="headerlink" title="设置日志输出格"></a>设置日志输出格</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image608.gif" alt="desc"></p><h3 id="3-日志文件"><a href="#3-日志文件" class="headerlink" title="3. 日志文件"></a>3. 日志文件</h3><h4 id="设置日志文件"><a href="#设置日志文件" class="headerlink" title="设置日志文件"></a>设置日志文件</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image610.gif" alt="desc"></p><h4 id="日志文件详细配置"><a href="#日志文件详细配置" class="headerlink" title="日志文件详细配置"></a>日志文件详细配置</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image612.gif" alt="desc"></p><h1 id="原理篇"><a href="#原理篇" class="headerlink" title="原理篇"></a>原理篇</h1><h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><h3 id="bean的加载方式"><a href="#bean的加载方式" class="headerlink" title="bean的加载方式"></a>bean的加载方式</h3><h4 id="1-XML方式声明bean"><a href="#1-XML方式声明bean" class="headerlink" title="1. XML方式声明bean"></a>1. XML方式声明bean</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image614.gif" alt="desc"></p><h4 id="2-XML-注解方式声明bean"><a href="#2-XML-注解方式声明bean" class="headerlink" title="2. XML+注解方式声明bean"></a>2. XML+注解方式声明bean</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image616.gif" alt="desc"></p><p>•   其他注解方式</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image618.gif" alt="desc"></p><h4 id="3-注解方式声明配置类"><a href="#3-注解方式声明配置类" class="headerlink" title="3. 注解方式声明配置类"></a>3. 注解方式声明配置类</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image620.gif" alt="desc"></p><p>•   扩展1</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image622.gif" alt="desc"></p><p>•   扩展2</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image624.gif" alt="desc"></p><p>•   扩展3</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image626.gif" alt="desc"></p><h4 id="4-使用-Import注解导入要注入的bean对应的字节码"><a href="#4-使用-Import注解导入要注入的bean对应的字节码" class="headerlink" title="4. 使用@Import注解导入要注入的bean对应的字节码"></a>4. 使用@Import注解导入要注入的bean对应的字节码</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image628.gif" alt="desc"></p><p>•   扩展4</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image630.gif" alt="desc"></p><h4 id="5-使用上下文对象在容器初始化完毕后注入bean"><a href="#5-使用上下文对象在容器初始化完毕后注入bean" class="headerlink" title="5. 使用上下文对象在容器初始化完毕后注入bean"></a>5. 使用上下文对象在容器初始化完毕后注入bean</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image632.gif" alt="desc"></p><h4 id="6-导入实现了ImportSelector接口的类，实现对导入源的编程式处理"><a href="#6-导入实现了ImportSelector接口的类，实现对导入源的编程式处理" class="headerlink" title="6. 导入实现了ImportSelector接口的类，实现对导入源的编程式处理"></a>6. 导入实现了ImportSelector接口的类，实现对导入源的编程式处理</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image634.gif" alt="desc"></p><h4 id="7-导入实现了ImportBeanDefinitionRegistrar接口的类"><a href="#7-导入实现了ImportBeanDefinitionRegistrar接口的类" class="headerlink" title="7. 导入实现了ImportBeanDefinitionRegistrar接口的类"></a>7. 导入实现了ImportBeanDefinitionRegistrar接口的类</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image636.gif" alt="desc"></p><h4 id="8-导入实现了BeanDefinitionRegistryPostProcessor接口的类"><a href="#8-导入实现了BeanDefinitionRegistryPostProcessor接口的类" class="headerlink" title="8. 导入实现了BeanDefinitionRegistryPostProcessor接口的类"></a>8. 导入实现了BeanDefinitionRegistryPostProcessor接口的类</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image638.gif" alt="desc"></p><h3 id="bean的加载控制"><a href="#bean的加载控制" class="headerlink" title="bean的加载控制"></a>bean的加载控制</h3><h4 id="bean的加载控制指根据特定情况对bean进行选择性加载以达到适用于项目的目标。"><a href="#bean的加载控制指根据特定情况对bean进行选择性加载以达到适用于项目的目标。" class="headerlink" title="bean的加载控制指根据特定情况对bean进行选择性加载以达到适用于项目的目标。"></a>bean的加载控制指根据特定情况对bean进行选择性加载以达到适用于项目的目标。</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image640.gif" alt="desc"></p><h4 id="根据任意条件确认是否加载bean"><a href="#根据任意条件确认是否加载bean" class="headerlink" title="根据任意条件确认是否加载bean"></a>根据任意条件确认是否加载bean</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image642.gif" alt="desc"></p><h4 id="使用-Conditional注解的派生注解设置各种组合条件控制bean的加载"><a href="#使用-Conditional注解的派生注解设置各种组合条件控制bean的加载" class="headerlink" title="使用@Conditional注解的派生注解设置各种组合条件控制bean的加载"></a>使用@Conditional注解的派生注解设置各种组合条件控制bean的加载</h4><p>•   匹配指定类</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image644.gif" alt="desc"></p><p>•   未匹配指定类</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image646.gif" alt="desc"></p><p>•   匹配指定类型的bean</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image648.gif" alt="desc"></p><p>•   匹配指定名称的bean</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image650.gif" alt="desc"></p><p>•   匹配指定环境</p><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image652.gif" alt="desc"></p><h3 id="bean依赖属性配置"><a href="#bean依赖属性配置" class="headerlink" title="bean依赖属性配置"></a>bean依赖属性配置</h3><h4 id="将业务功能bean运行需要的资源抽取成独立的属性类（-Properties），设置读取配置文件信息"><a href="#将业务功能bean运行需要的资源抽取成独立的属性类（-Properties），设置读取配置文件信息" class="headerlink" title="将业务功能bean运行需要的资源抽取成独立的属性类（******Properties），设置读取配置文件信息"></a>将业务功能bean运行需要的资源抽取成独立的属性类（******Properties），设置读取配置文件信息</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image654.gif" alt="desc"></p><h4 id="配置文件中使用固定格式为属性类注入数据"><a href="#配置文件中使用固定格式为属性类注入数据" class="headerlink" title="配置文件中使用固定格式为属性类注入数据"></a>配置文件中使用固定格式为属性类注入数据</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image656.gif" alt="desc"></p><h4 id="定义业务功能bean，通常使用-Import导入，解耦强制加载bean"><a href="#定义业务功能bean，通常使用-Import导入，解耦强制加载bean" class="headerlink" title="定义业务功能bean，通常使用@Import导入，解耦强制加载bean"></a>定义业务功能bean，通常使用@Import导入，解耦强制加载bean</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image658.gif" alt="desc"></p><h4 id="使用-EnableConfigurationProperties注解设定使用属性类时加载bean"><a href="#使用-EnableConfigurationProperties注解设定使用属性类时加载bean" class="headerlink" title="使用@EnableConfigurationProperties注解设定使用属性类时加载bean"></a>使用@EnableConfigurationProperties注解设定使用属性类时加载bean</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image660.gif" alt="desc"></p><h3 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><h4 id="-5"><a href="#-5" class="headerlink" title></a></h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image662.gif" alt="desc"></p><h3 id="变更自动配置"><a href="#变更自动配置" class="headerlink" title="变更自动配置"></a>变更自动配置</h3><h4 id="自定义自动配置（META-INF-x2F-spring-factories）"><a href="#自定义自动配置（META-INF-x2F-spring-factories）" class="headerlink" title="自定义自动配置（META-INF&#x2F;spring.factories）"></a>自定义自动配置（META-INF&#x2F;spring.factories）</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image664.gif" alt="desc"></p><h4 id="控制SpringBoot内置自动配置类加载"><a href="#控制SpringBoot内置自动配置类加载" class="headerlink" title="控制SpringBoot内置自动配置类加载"></a>控制SpringBoot内置自动配置类加载</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image666.gif" alt="desc"></p><h4 id="变更自动配置：去除tomcat自动配置（条件激活），添加jetty自动配置（条件激活）"><a href="#变更自动配置：去除tomcat自动配置（条件激活），添加jetty自动配置（条件激活）" class="headerlink" title="变更自动配置：去除tomcat自动配置（条件激活），添加jetty自动配置（条件激活）"></a>变更自动配置：去除tomcat自动配置（条件激活），添加jetty自动配置（条件激活）</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image668.gif" alt="desc"></p><h2 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h2><h3 id="案例：统计独立IP访问次数"><a href="#案例：统计独立IP访问次数" class="headerlink" title="案例：统计独立IP访问次数"></a>案例：统计独立IP访问次数</h3><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image670.gif" alt="desc"></p><h3 id="自定义starter-1"><a href="#自定义starter-1" class="headerlink" title="自定义starter"></a>自定义starter</h3><h4 id="业务功能开发"><a href="#业务功能开发" class="headerlink" title="业务功能开发"></a>业务功能开发</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image672.gif" alt="desc"></p><h4 id="自动配置类"><a href="#自动配置类" class="headerlink" title="自动配置类"></a>自动配置类</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image674.gif" alt="desc"></p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image676.gif" alt="desc"></p><h4 id="模拟调用（非最终版）"><a href="#模拟调用（非最终版）" class="headerlink" title="模拟调用（非最终版）"></a>模拟调用（非最终版）</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image678.gif" alt="desc"></p><h4 id="开启定时任务功能"><a href="#开启定时任务功能" class="headerlink" title="开启定时任务功能"></a>开启定时任务功能</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image680.gif" alt="desc"></p><h4 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image682.gif" alt="desc"></p><h4 id="定义属性类，加载对应属性"><a href="#定义属性类，加载对应属性" class="headerlink" title="定义属性类，加载对应属性"></a>定义属性类，加载对应属性</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image684.gif" alt="desc"></p><h4 id="设置加载Properties类为bean"><a href="#设置加载Properties类为bean" class="headerlink" title="设置加载Properties类为bean"></a>设置加载Properties类为bean</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image686.gif" alt="desc"></p><h4 id="根据配置切换设置"><a href="#根据配置切换设置" class="headerlink" title="根据配置切换设置"></a>根据配置切换设置</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image688.gif" alt="desc"></p><h4 id="明细模式报表模板"><a href="#明细模式报表模板" class="headerlink" title="明细模式报表模板"></a>明细模式报表模板</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image690.gif" alt="desc"></p><h4 id="极简模式报表模板"><a href="#极简模式报表模板" class="headerlink" title="极简模式报表模板"></a>极简模式报表模板</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image692.gif" alt="desc"></p><h4 id="配置信息-1"><a href="#配置信息-1" class="headerlink" title="配置信息"></a>配置信息</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image694.gif" alt="desc"></p><h4 id="自定义bean名称"><a href="#自定义bean名称" class="headerlink" title="自定义bean名称"></a>自定义bean名称</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image696.gif" alt="desc"></p><h4 id="放弃配置属性创建bean方式，改为手工控制"><a href="#放弃配置属性创建bean方式，改为手工控制" class="headerlink" title="放弃配置属性创建bean方式，改为手工控制"></a>放弃配置属性创建bean方式，改为手工控制</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image698.gif" alt="desc"></p><h4 id="使用-beanName-attrName-读取bean的属性"><a href="#使用-beanName-attrName-读取bean的属性" class="headerlink" title="使用#{beanName.attrName}读取bean的属性"></a>使用#{beanName.attrName}读取bean的属性</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image700.gif" alt="desc"></p><h4 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image702.gif" alt="desc"></p><h4 id="设置核心配置类，加载拦截器"><a href="#设置核心配置类，加载拦截器" class="headerlink" title="设置核心配置类，加载拦截器"></a>设置核心配置类，加载拦截器</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image704.gif" alt="desc"></p><h3 id="辅助功能开发"><a href="#辅助功能开发" class="headerlink" title="辅助功能开发"></a>辅助功能开发</h3><h4 id="导入配置处理器坐标"><a href="#导入配置处理器坐标" class="headerlink" title="导入配置处理器坐标"></a>导入配置处理器坐标</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image706.gif" alt="desc"></p><h4 id="进行自定义提示功能开发"><a href="#进行自定义提示功能开发" class="headerlink" title="进行自定义提示功能开发"></a>进行自定义提示功能开发</h4><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image708.gif" alt="desc"></p><h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><h3 id="SpringBoot启动流程"><a href="#SpringBoot启动流程" class="headerlink" title="SpringBoot启动流程"></a>SpringBoot启动流程</h3><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image710.gif" alt="desc"></p><h3 id="监听器类型"><a href="#监听器类型" class="headerlink" title="监听器类型"></a>监听器类型</h3><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image712.gif" alt="desc"></p><h1 id="Spring程序与SpringBoot程序对比"><a href="#Spring程序与SpringBoot程序对比" class="headerlink" title="Spring程序与SpringBoot程序对比"></a>Spring程序与SpringBoot程序对比</h1><p><img src="/2022/12/31/SpringBoot%E5%AD%A6%E4%B9%A0/clip_image714.gif" alt="desc"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> StringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 学习</title>
      <link href="/2022/12/28/React-%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/12/28/React-%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是React-（★★★）"><a href="#什么是React-（★★★）" class="headerlink" title="什么是React （★★★）"></a>什么是React （★★★）</h2><p>React是一个用于构建用户界面的javaScript库，起源于facebook的内部项目，后续在13年开源了出来</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>声明式</li></ul><p>你只需要描述UI看起来是什么样式，就跟写HTML一样，React负责渲染UI</p><ul><li>基于组件</li></ul><p>组件时React最重要的内容，组件表示页面中的部分内容</p><ul><li>学习一次，随处使用</li></ul><p>使用React可以开发Web应用，使用React可以开发移动端，可以开发VR应用</p><span id="more"></span><h2 id="React基本使用"><a href="#React基本使用" class="headerlink" title="React基本使用"></a>React基本使用</h2><h3 id="React的安装"><a href="#React的安装" class="headerlink" title="React的安装"></a>React的安装</h3><p>npm i react react-dom </p><ul><li>react 包是核心，提供创建元素，组件等功能</li><li>react-dom 包提供DOM相关功能</li></ul><h3 id="React的使用"><a href="#React的使用" class="headerlink" title="React的使用"></a>React的使用</h3><ul><li>引入react和react-dom的两个js文件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./node_modules/react/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./node_modules/react-dom/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>创建React元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建元素节点</span></span><br><span class="line"><span class="comment">// 1. 元素名称</span></span><br><span class="line"><span class="comment">// 2. 元素属性 传递的是个对象</span></span><br><span class="line"><span class="comment">// 3. 元素内容</span></span><br><span class="line"><span class="keyword">let</span> title = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;hellow react&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>渲染到页面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染到页面</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(title, root)</span><br></pre></td></tr></table></figure><h2 id="React脚手架（★★★）"><a href="#React脚手架（★★★）" class="headerlink" title="React脚手架（★★★）"></a>React脚手架（★★★）</h2><h3 id="React脚手架意义"><a href="#React脚手架意义" class="headerlink" title="React脚手架意义"></a>React脚手架意义</h3><ul><li>脚手架是开发现代Web应用的必备</li><li>充分利用 Webpack，Babel，ESLint等工具辅助项目开发</li><li>零配置，无需手动配置繁琐的工具即可使用</li><li>关注业务，而不是工具配置</li></ul><h3 id="使用React脚手架初始化项目"><a href="#使用React脚手架初始化项目" class="headerlink" title="使用React脚手架初始化项目"></a>使用React脚手架初始化项目</h3><ul><li>初始化项目，命令： npx create-react-app my-pro<ul><li>npx 目的：提升包内提供的命令行工具的使用体验</li><li>原来：先安装脚手架包，再使用这个包中提供的命令</li><li>现在：无需安装脚手架包，就可以直接使用这个包提供的命令</li><li>create-react-app  这个是脚手架名称 不能随意更改</li><li>my-pro  自己定义的项目名称</li></ul></li><li>启动项目，在项目根目录执行命令： npm start</li></ul><p>yarn命令简介</p><ul><li>yarn 是Facebook发布的包管理器，可以看做是npm的替代品，功能与npm相同</li><li>yarn具有快速，可靠和安全的特点</li><li>初始化新项目：yarn init</li><li>安装包： yarn add 包名称</li><li>安装项目依赖： yarn</li></ul><h3 id="脚手架中使用React"><a href="#脚手架中使用React" class="headerlink" title="脚手架中使用React"></a>脚手架中使用React</h3><ul><li>导入react和react-dom两个包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br></pre></td></tr></table></figure><ul><li>创建元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let h1 = React.createElement(&#x27;h1&#x27;,null,&#x27;我是标题&#x27;)</span><br></pre></td></tr></table></figure><ul><li>渲染到页面</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(h1,document.getElementById(&#x27;root&#x27;))</span><br></pre></td></tr></table></figure><h1 id="JSX的使用"><a href="#JSX的使用" class="headerlink" title="JSX的使用"></a>JSX的使用</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h4 id="JSX产生的原因"><a href="#JSX产生的原因" class="headerlink" title="JSX产生的原因"></a>JSX产生的原因</h4><p>由于通过createElement()方法创建的React元素有一些问题，代码比较繁琐，结构不直观，无法一眼看出描述的结构，不优雅，用户体验不爽</p><h4 id="JSX的概述"><a href="#JSX的概述" class="headerlink" title="JSX的概述"></a>JSX的概述</h4><p>JSX是JavaScript XML 的简写，表示在JavaScript代码中写HTML格式的代码</p><p>优势：声明式语法更加直观，与HTML结构相同，降低了学习成本，提升开发效率</p><h2 id="简单入门使用（★★★）"><a href="#简单入门使用（★★★）" class="headerlink" title="简单入门使用（★★★）"></a>简单入门使用（★★★）</h2><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ul><li>使用JSX语法创建react元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let h1 = &lt;h1&gt;我是通过JSX创建的元素&lt;/h1&gt;</span><br></pre></td></tr></table></figure><ul><li>使用ReactDOM来渲染元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(h1,document.getElementById(&#x27;root&#x27;))</span><br></pre></td></tr></table></figure><h4 id="为什么在脚手架中可以使用JSX语法"><a href="#为什么在脚手架中可以使用JSX语法" class="headerlink" title="为什么在脚手架中可以使用JSX语法"></a>为什么在脚手架中可以使用JSX语法</h4><ul><li>JSX 不是标准的ECMAScript语法，它是ECMAScript的语法拓展</li><li>需要使用babel编译处理后，才能在浏览器环境中使用</li><li>create-react-app脚手架中已经默认有该配置，无需手动配置</li><li>编译JSX语法的包： @bable&#x2F;preset-react</li></ul><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li>React元素的属性名使用驼峰命名法</li><li>特殊属性名：class -&gt; className，for -&gt; htmlFor，tabindex -&gt; tabIndex</li><li>如果没有子节点的React元素可以用 <code>/&gt;</code> 来结束</li><li>推荐：使用 小括号包裹JSX，从而避免JS中自动插入分号报错</li></ul><h2 id="JSX语法（★★★）"><a href="#JSX语法（★★★）" class="headerlink" title="JSX语法（★★★）"></a>JSX语法（★★★）</h2><p>JSX是来描述页面的结构，我们一般在编写业务逻辑渲染页面的时候，需要涉及到传递值，调用函数，判断条件，循环等，这一些在JSX中都能得到支持</p><h4 id="嵌入JS表达式"><a href="#嵌入JS表达式" class="headerlink" title="嵌入JS表达式"></a>嵌入JS表达式</h4><p>语法：{JavaScritp表达式}</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let content = &#x27;插入的内容&#x27;</span><br><span class="line">let h1 = &lt;h1&gt;我是通过JSX创建的元素+ &#123;content&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><ul><li>只要是合法的js表达式都可以进行嵌入</li><li>JSX自身也是js表达式</li><li>注意：js中的对象是一个例外，一般只会出现在style属性中</li><li>注意：在{}中不能出现语句</li></ul><h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><p>根据不同的条件来渲染不同的JSX结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let isLoading = true</span><br><span class="line">let loading = ()=&gt;&#123;</span><br><span class="line">    if(isLoading)&#123;</span><br><span class="line">        return &lt;div&gt;Loading...&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;div&gt;加载完成&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，写JSX的条件渲染与我们之前编写代码的逻辑是差不多的，根据不同的判断逻辑，返回不同的 JSX结构，然后渲染到页面中</p><h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><ul><li>如果需要渲染一组数据，我们应该使用数组的 map () 方法</li><li>注意：渲染列表的时候需要添加key属性，key属性的值要保证唯一</li><li>原则：map()遍历谁，就给谁添加key属性</li><li>注意：尽量避免使用索引号作为key</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#123;</span><br><span class="line">    id:1,</span><br><span class="line">    name:&#x27;三国演义&#x27;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    id:2,</span><br><span class="line">    name:&#x27;水浒传&#x27;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    id:3,</span><br><span class="line">    name:&#x27;西游记&#x27;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    id:4,</span><br><span class="line">    name:&#x27;红楼梦&#x27;</span><br><span class="line">&#125;]</span><br><span class="line">let ul = (&lt;ul&gt;</span><br><span class="line">    &#123;arr.map(item =&gt; &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;)&#125;</span><br><span class="line">&lt;/ul&gt;)</span><br><span class="line">ReactDOM.render(ul,document.getElementById(&#x27;root&#x27;))</span><br></pre></td></tr></table></figure><h4 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h4><h5 id="行内样式-style"><a href="#行内样式-style" class="headerlink" title="行内样式 -style"></a>行内样式 -style</h5><p>在style里面我们通过对象的方式传递数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li key=&#123;item.id&#125; style=&#123;&#123;&#x27;color&#x27;: &#x27;red&#x27;,&quot;backgroundColor&quot;: &#x27;pink&#x27;&#125;&#125;&gt;&#123;item.name&#125;&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>这种方式比较的麻烦，不方便进行阅读，而且还会导致代码比较的繁琐</p><h5 id="类名-className"><a href="#类名-className" class="headerlink" title="类名 -className"></a>类名 -className</h5><p>创建CSS文件编写样式代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在js中进行引入，然后设置类名即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;./css/index.css&#x27;</span><br><span class="line"></span><br><span class="line">&lt;li className=&#x27;container&#x27; key=&#123;item.id&#125; style=&#123;&#123;&#x27;color&#x27;: &#x27;red&#x27;,&quot;backgroundColor&quot;: &#x27;pink&#x27;&#125;&#125;&gt;&#123;item.name&#125;&lt;/li&gt;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>JSX是React的核心内容</li><li>JSX表示在JS代码中写HTML结构，是React声明式的体现</li><li>使用JSX配合嵌入的JS表达式、条件渲染、列表渲染、可以描述任意UI结构</li><li>推荐使用className的方式给JSX添加样式</li><li>React完全利用JS语言自身的能力来编写UI，而不是造轮子增强HTML功能</li></ul><h1 id="React组件"><a href="#React组件" class="headerlink" title="React组件"></a>React组件</h1><h2 id="React组件介绍"><a href="#React组件介绍" class="headerlink" title="React组件介绍"></a>React组件介绍</h2><ul><li>组件是React的一等公民，使用React就是在用组件</li><li>组件表示页面中的部分功能</li><li>组合多个组件实现完整的页面功能</li><li>特点：可复用、独立、可组合</li></ul><p><img src="/2022/12/28/React-%E5%AD%A6%E4%B9%A0/%E7%BB%84%E4%BB%B6.png"></p><h2 id="组件的创建方式"><a href="#组件的创建方式" class="headerlink" title="组件的创建方式"></a>组件的创建方式</h2><h3 id="函数创建组件"><a href="#函数创建组件" class="headerlink" title="函数创建组件"></a>函数创建组件</h3><ul><li>函数组件：使用JS的函数创建组件</li><li><strong>约定1：</strong>函数名称必须以大写字母开头</li><li><strong>约定2：</strong>函数组件必须有返回值，表示该组件的结构</li><li>如果返回值为null，表示不渲染任何内容</li></ul><h4 id="示例demo"><a href="#示例demo" class="headerlink" title="示例demo"></a>示例demo</h4><p>编写函数组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Hello() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;这是第一个函数组件&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用ReactDOM.render()进行渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;Hello /&gt;,document.getElementById(&#x27;root&#x27;))</span><br></pre></td></tr></table></figure><h3 id="类组件（★★★）"><a href="#类组件（★★★）" class="headerlink" title="类组件（★★★）"></a>类组件（★★★）</h3><ul><li>使用ES6语法的class创建的组件</li><li>约定1：类名称也必须要大写字母开头</li><li>约定2：类组件应该继承React.Component父类，从而可以使用父类中提供的方法或者属性</li><li>约定3：类组件必须提供 render 方法</li><li>约定4：render方法中必须要有return返回值</li></ul><h4 id="示例demo-1"><a href="#示例demo-1" class="headerlink" title="示例demo"></a>示例demo</h4><p>创建class类，继承React.Component，在里面提供render方法，在return里面返回内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Hello extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;这是第一个类组件&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过ReactDOM进行渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;Hello /&gt;,document.getElementById(&#x27;root&#x27;))</span><br></pre></td></tr></table></figure><h3 id="抽离成单独的JS文件（★★★）"><a href="#抽离成单独的JS文件（★★★）" class="headerlink" title="抽离成单独的JS文件（★★★）"></a>抽离成单独的JS文件（★★★）</h3><ul><li>思考：项目中组件多了之后，该如何组织这些组件？</li><li>选择一：将所有的组件放在同一个JS文件中</li><li>选择二：将每个组件放到单独的JS文件中</li><li><strong>组件作为一个独立的个体，一般都会放到一个单独的JS文件中</strong></li></ul><h4 id="示例demo-2"><a href="#示例demo-2" class="headerlink" title="示例demo"></a>示例demo</h4><ul><li>创建Hello.js</li><li>在Hello.js 中导入React，创建组件，在Hello.js中导出</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">export default class extends React.Component &#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;单独抽离出来的 Hello&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在index.js中导入Hello组件，渲染到页面</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Hello from &#x27;./js/Hello&#x27;</span><br><span class="line">ReactDOM.render(&lt;Hello /&gt;,document.getElementById(&#x27;root&#x27;))</span><br></pre></td></tr></table></figure><h2 id="React事件处理（★★★）"><a href="#React事件处理（★★★）" class="headerlink" title="React事件处理（★★★）"></a>React事件处理（★★★）</h2><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><ul><li>React事件绑定语法与DOM事件语法相似</li><li>语法：on+事件名称&#x3D;事件处理函数，比如  onClick &#x3D; function(){}</li><li>注意：React事件采用驼峰命名法</li></ul><h4 id="示例demo-3"><a href="#示例demo-3" class="headerlink" title="示例demo"></a>示例demo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default class extends React.Component &#123;</span><br><span class="line">    clickHandle(e)&#123;</span><br><span class="line">        console.log(&#x27;点了&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;&lt;button onClick = &#123;this.clickHandle&#125;&gt;点我点我点我&lt;/button&gt;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>在React中绑定事件与原生很类似</li><li>需要注意点在于，在React绑定事件需要遵循驼峰命名法</li><li>类组件与函数组件绑定事件是差不多的，只是在类组件中绑定事件函数的时候需要用到this，代表指向当前的类的引用，在函数中不需要调用this</li></ul><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><ul><li>可以通过事件处理函数的参数获取到事件对象</li><li>React中的事件对象叫做：合成事件</li><li>合成事件：兼容所有浏览器，无需担心跨浏览器兼容问题</li><li>除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口，包括 <code>stopPropagation()</code>和 <code>preventDefault()</code></li><li>如果你想获取到原生事件对象，可以通过 <code>nativeEvent</code> 属性来进行获取</li></ul><h4 id="示例demo-4"><a href="#示例demo-4" class="headerlink" title="示例demo"></a>示例demo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default class extends React.Component &#123;</span><br><span class="line">    clickHandle(e)&#123;</span><br><span class="line">        // 获取原生事件对象</span><br><span class="line">        console.log(e.nativeEvent)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;&lt;button onClick = &#123;this.clickHandle&#125;&gt;点我点我点我&lt;/button&gt;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="支持的事件"><a href="#支持的事件" class="headerlink" title="支持的事件"></a>支持的事件</h3><ul><li><p>Clipboard Events  剪切板事件</p><ul><li>事件名 ：onCopy onCut onPaste</li><li>属性     ：DOMDataTransfer clipboardData</li></ul></li><li><p>compositionEvent  复合事件</p><ul><li>事件名： onCompositionEnd onCompositionStart onCompositionUpdate</li><li>属性： string data</li></ul></li><li><p>Keyboard Events  键盘事件</p><ul><li>事件名：onKeyDown onKeyPress onKeyUp</li><li>属性： 例如 number keyCode  太多就不一一列举</li></ul></li><li><p>Focus Events  焦点事件  （这些焦点事件在 React DOM 上的所有元素都有效，不只是表单元素）</p><ul><li>事件名： onFocus onBlur</li><li>属性： DOMEventTarget relatedTarget</li></ul></li><li><p>Form Events  表单事件</p><ul><li>事件名： onChange onInput onInvalid onSubmit</li></ul></li><li><p>Mouse Events  鼠标事件</p><ul><li><p>事件名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExit</span><br><span class="line">onDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave</span><br><span class="line">onMouseMove onMouseOut onMouseOver onMouseUp</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Pointer Events  指针事件</p><ul><li><p>事件名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onPointerDown onPointerMove onPointerUp onPointerCancel onGotPointerCapture</span><br><span class="line">onLostPointerCapture onPointerEnter onPointerLeave onPointerOver onPointerOut</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Selection Events  选择事件</p><ul><li>事件名：onSelect</li></ul></li><li><p>Touch Events  触摸事件</p><ul><li>事件名：onTouchCancel onTouchEnd onTouchMove onTouchStart</li></ul></li><li><p>UI Events  UI 事件</p><ul><li>事件名： onScroll</li></ul></li><li><p>Wheel Events  滚轮事件</p><ul><li><p>事件名：onWheel</p></li><li><p>属性： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">number deltaMode</span><br><span class="line">number deltaX</span><br><span class="line">number deltaY</span><br><span class="line">number deltaZ</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Media Events  媒体事件</p><ul><li><p>事件名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncrypted</span><br><span class="line">onEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlay</span><br><span class="line">onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend</span><br><span class="line">onTimeUpdate onVolumeChange onWaiting</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Image Events 图像事件</p><ul><li>事件名：onLoad onError</li></ul></li><li><p>Animation Events 动画事件</p><ul><li>事件名：onAnimationStart onAnimationEnd onAnimationIteration</li></ul></li><li><p>Transition Events 过渡事件</p><ul><li>事件名：onTransitionEnd</li></ul></li><li><p>Other Events  其他事件</p><ul><li>事件名： onToggle</li></ul></li></ul><h2 id="有状态组件和无状态组件"><a href="#有状态组件和无状态组件" class="headerlink" title="有状态组件和无状态组件"></a>有状态组件和无状态组件</h2><ul><li>函数组件又叫做 无状态组件，类组件又叫做 有状态组件</li><li>状态(state) 即数据</li><li>函数组件没有自己的状态，只负责数据展示</li><li>类组件有自己的状态，负责更新UI，让页面动起来</li></ul><p><img src="/2022/12/28/React-%E5%AD%A6%E4%B9%A0/%E7%8A%B6%E6%80%81.png"></p><h2 id="State和SetState（★★★）"><a href="#State和SetState（★★★）" class="headerlink" title="State和SetState（★★★）"></a>State和SetState（★★★）</h2><h3 id="state基本使用"><a href="#state基本使用" class="headerlink" title="state基本使用"></a>state基本使用</h3><ul><li>状态(state)即数据，是组件内部的私有数据，只能在组件内部使用</li><li>state的值是对象，表示一个组件中可以有多个数据</li><li>通过this.state来获取状态</li></ul><h4 id="示例demo-5"><a href="#示例demo-5" class="headerlink" title="示例demo"></a>示例demo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export default class extends React.Component &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super()</span><br><span class="line"></span><br><span class="line">        // 第一种初始化方式</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            count : 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 第二种初始化方式</span><br><span class="line">    state = &#123;</span><br><span class="line">        count:1</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;计数器 :&#123;this.state.count&#125;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="setState-修改状态"><a href="#setState-修改状态" class="headerlink" title="setState() 修改状态"></a>setState() 修改状态</h3><ul><li>状态是可变的</li><li>语法：this.setState({要修改的数据})</li><li><strong>注意：不要直接修改state中的值，这是错误的</strong></li><li>setState() 作用：1.修改 state 2.更新UI</li><li>思想：数据驱动视图</li></ul><p><img src="/2022/12/28/React-%E5%AD%A6%E4%B9%A0/%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81.png"></p><h4 id="示例demo-6"><a href="#示例demo-6" class="headerlink" title="示例demo"></a>示例demo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export default class extends React.Component &#123;</span><br><span class="line">    // 第二种初始化方式</span><br><span class="line">    state = &#123;</span><br><span class="line">        count:1</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div&gt;计数器 :&#123;this.state.count&#125;&lt;/div&gt;</span><br><span class="line">                &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">                     this.setState(&#123;</span><br><span class="line">             count: this.state.count+1</span><br><span class="line">             &#125;)   </span><br><span class="line">                &#125;&#125;&gt;+1&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul><li>修改state里面的值我们需要通过 this.setState() 来进行修改</li><li>React底层会有监听，一旦我们调用了setState导致了数据的变化，就会重新调用一次render方法，重新渲染当前组件</li></ul><h3 id="抽取事件处理函数"><a href="#抽取事件处理函数" class="headerlink" title="抽取事件处理函数"></a>抽取事件处理函数</h3><ul><li>当我们把上面代码的事件处理程序抽取出来后，会报错，找不到this</li></ul><p><img src="/2022/12/28/React-%E5%AD%A6%E4%B9%A0/this%E6%89%BE%E4%B8%8D%E5%88%B0.png"></p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul><li>在JSX中我们写的事件处理函数可以找到this，原因在于在JSX中我们利用箭头函数，箭头函数是不会绑定this，所以会向外一层去寻找，外层是render方法，在render方法里面的this刚好指向的是当前实例对象</li></ul><h2 id="事件绑定this指向"><a href="#事件绑定this指向" class="headerlink" title="事件绑定this指向"></a>事件绑定this指向</h2><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ul><li>利用箭头函数自身不绑定this的特点</li></ul><p><img src="/2022/12/28/React-%E5%AD%A6%E4%B9%A0/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0.png"></p><h3 id="利用bind方法（★★★）"><a href="#利用bind方法（★★★）" class="headerlink" title="利用bind方法（★★★）"></a>利用bind方法（★★★）</h3><p>利用原型bind方法是可以更改函数里面this的指向的，所以我们可以在构造中调用bind方法，然后把返回的值赋值给我们的函数即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super()</span><br><span class="line">...</span><br><span class="line">    // 通过bind方法改变了当前函数中this的指向</span><br><span class="line">    this.onIncrement = this.onIncrement.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line">  // 事件处理程序</span><br><span class="line">  onIncrement() &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="class的实例方法（★★★）"><a href="#class的实例方法（★★★）" class="headerlink" title="class的实例方法（★★★）"></a>class的实例方法（★★★）</h3><ul><li>利用箭头函数形式的class实例方法</li><li>注意：该语法是实验性语法，但是，由于babel的存在可以使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 事件处理程序</span><br><span class="line">onIncrement = () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;事件处理程序中的this：&#x27;, this)</span><br><span class="line">  this.setState(&#123;</span><br><span class="line">    count: this.state.count + 1</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ul><li>推荐：使用class的实例方法，也是依赖箭头函数不绑定this的原因</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring cloud 学习</title>
      <link href="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-微服务"><a href="#1-微服务" class="headerlink" title="1.微服务"></a>1.微服务</h1><p>随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？</p><span id="more"></span><h2 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1.单体架构"></a>1.1.单体架构</h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713202807818.png" alt="image-20210713202807818"></p><p>单体架构的优缺点如下：</p><p><strong>优点：</strong></p><ul><li>架构简单</li><li>部署成本低</li></ul><p><strong>缺点：</strong></p><ul><li>耦合度高（维护困难、升级困难）</li></ul><h2 id="1-2-分布式架构"><a href="#1-2-分布式架构" class="headerlink" title="1.2.分布式架构"></a>1.2.分布式架构</h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713203124797.png" alt="image-20210713203124797"></p><p>分布式架构的优缺点：</p><p><strong>优点：</strong></p><ul><li>降低服务耦合</li><li>有利于服务升级和拓展</li></ul><p><strong>缺点：</strong></p><ul><li>服务调用关系错综复杂</li></ul><p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p>人们需要制定一套行之有效的标准来约束分布式架构。</p><h2 id="1-3-微服务"><a href="#1-3-微服务" class="headerlink" title="1.3.微服务"></a>1.3.微服务</h2><p>微服务的架构特征：</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li><li>自治：团队独立、技术独立、数据独立，独立部署和交付</li><li>面向服务：服务提供统一标准的接口，与语言和技术无关</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713203753373.png" alt="image-20210713203753373"></p><p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><p>因此，可以认为<strong>微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p><p>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</p><p>其中在Java领域最引人注目的就是SpringCloud提供的方案了。</p><h2 id="1-4-SpringCloud"><a href="#1-4-SpringCloud" class="headerlink" title="1.4.SpringCloud"></a>1.4.SpringCloud</h2><p>SpringCloud是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p><p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713204155887.png" alt="image-20210713204155887"></p><p>另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713205003790.png" alt="image-20210713205003790"></p><p>我们课堂学习的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。</p><h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5.总结"></a>1.5.总结</h2><ul><li><p>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</p></li><li><p>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</p></li><li><p>微服务：一种良好的分布式架构方案</p><p>①优点：拆分粒度更小、服务更独立、耦合度更低</p><p>②缺点：架构非常复杂，运维、监控、部署难度提高</p></li><li><p>SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</p></li></ul><h1 id="2-服务拆分和远程调用"><a href="#2-服务拆分和远程调用" class="headerlink" title="2.服务拆分和远程调用"></a>2.服务拆分和远程调用</h1><p>任何分布式架构都离不开服务的拆分，微服务也是一样。</p><h2 id="2-1-服务拆分原则"><a href="#2-1-服务拆分原则" class="headerlink" title="2.1.服务拆分原则"></a>2.1.服务拆分原则</h2><p>这里我总结了微服务拆分时的几个原则：</p><ul><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li></ul><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713210800950.png" alt="image-20210713210800950"></p><h2 id="2-2-服务拆分示例"><a href="#2-2-服务拆分示例" class="headerlink" title="2.2.服务拆分示例"></a>2.2.服务拆分示例</h2><p>以课前资料中的微服务cloud-demo为例，其结构如下：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713211009593.png" alt="image-20210713211009593"></p><p>cloud-demo：父工程，管理依赖</p><ul><li>order-service：订单微服务，负责订单相关业务</li><li>user-service：用户微服务，负责用户相关业务</li></ul><p>要求：</p><ul><li>订单微服务和用户微服务都必须有各自的数据库，相互独立</li><li>订单服务和用户服务都对外暴露Restful的接口</li><li>订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库</li></ul><h3 id="2-2-1-导入Sql语句"><a href="#2-2-1-导入Sql语句" class="headerlink" title="2.2.1.导入Sql语句"></a>2.2.1.导入Sql语句</h3><p>首先，将课前资料提供的<code>cloud-order.sql</code>和<code>cloud-user.sql</code>导入到mysql中：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713211417049.png" alt="image-20210713211417049"></p><p>cloud-user表中初始数据如下：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713211550169.png" alt="image-20210713211550169"></p><p>cloud-order表中初始数据如下：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713211657319.png" alt="image-20210713211657319"></p><p>cloud-order表中持有cloud-user表中的id字段。</p><h3 id="2-2-2-导入demo工程"><a href="#2-2-2-导入demo工程" class="headerlink" title="2.2.2.导入demo工程"></a>2.2.2.导入demo工程</h3><p>用IDEA导入课前资料提供的Demo：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713211814094.png" alt="image-20210713211814094"></p><p>项目结构如下：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713212656887.png" alt="image-20210713212656887"></p><p>导入后，会在IDEA右下角出现弹窗：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713212349272.png" alt="image-20210713212349272"></p><p>点击弹窗，然后按下图选择：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713212336185.png" alt="image-20210713212336185"></p><p>会出现这样的菜单：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713212513324.png" alt="image-20210713212513324"></p><p>配置下项目使用的JDK：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713220736408.png" alt="image-20210713220736408"></p><h2 id="2-3-实现远程调用案例"><a href="#2-3-实现远程调用案例" class="headerlink" title="2.3.实现远程调用案例"></a>2.3.实现远程调用案例</h2><p>在order-service服务中，有一个根据id查询订单的接口：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713212749575.png" alt="image-20210713212749575"></p><p>根据id查询订单，返回值是Order对象，如图：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713212901725.png" alt="image-20210713212901725"></p><p>其中的user为null</p><p>在user-service中有一个根据id查询用户的接口：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713213146089.png" alt="image-20210713213146089"></p><p>查询的结果如图：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713213213075.png" alt="image-20210713213213075"></p><h3 id="2-3-1-案例需求："><a href="#2-3-1-案例需求：" class="headerlink" title="2.3.1.案例需求："></a>2.3.1.案例需求：</h3><p>修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713213312278.png" alt="image-20210713213312278"></p><p>因此，我们需要在order-service中 向user-service发起一个http的请求，调用<a href="http://localhost:8081/user/%7BuserId%7D%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E3%80%82">http://localhost:8081/user/{userId}这个接口。</a></p><p>大概的步骤是这样的：</p><ul><li>注册一个RestTemplate的实例到Spring容器</li><li>修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User</li><li>将查询的User填充到Order对象，一起返回</li></ul><h3 id="2-3-2-注册RestTemplate"><a href="#2-3-2-注册RestTemplate" class="headerlink" title="2.3.2.注册RestTemplate"></a>2.3.2.注册RestTemplate</h3><p>首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-实现远程调用"><a href="#2-3-3-实现远程调用" class="headerlink" title="2.3.3.实现远程调用"></a>2.3.3.实现远程调用</h3><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713213959569.png" alt="image-20210713213959569"></p><h2 id="2-4-提供者与消费者"><a href="#2-4-提供者与消费者" class="headerlink" title="2.4.提供者与消费者"></a>2.4.提供者与消费者</h2><p>在服务调用关系中，会有两个不同的角色：</p><p><strong>服务提供者</strong>：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</p><p><strong>服务消费者</strong>：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713214404481.png" alt="image-20210713214404481"></p><p>但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。</p><p>如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？</p><ul><li>对于A调用B的业务而言：A是服务消费者，B是服务提供者</li><li>对于B调用C的业务而言：B是服务消费者，C是服务提供者</li></ul><p>因此，服务B既可以是服务提供者，也可以是服务消费者。</p><h1 id="3-Eureka注册中心"><a href="#3-Eureka注册中心" class="headerlink" title="3.Eureka注册中心"></a>3.Eureka注册中心</h1><p>假如我们的服务提供者user-service部署了多个实例，如图：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713214925388.png" alt="image-20210713214925388"></p><p>大家思考几个问题：</p><ul><li>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</li><li>有多个user-service实例地址，order-service调用时该如何选择？</li><li>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</li></ul><h2 id="3-1-Eureka的结构和作用"><a href="#3-1-Eureka的结构和作用" class="headerlink" title="3.1.Eureka的结构和作用"></a>3.1.Eureka的结构和作用</h2><p>这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713220104956.png" alt="image-20210713220104956"></p><p>回答之前的各个问题。</p><p>问题1：order-service如何得知user-service实例地址？</p><p>获取地址信息的流程如下：</p><ul><li>user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册</li><li>eureka-server保存服务名称到服务实例地址列表的映射关系</li><li>order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li></ul><p>问题2：order-service如何从多个user-service实例中选择具体的实例？</p><ul><li>order-service从实例列表中利用负载均衡算法选中一个实例地址</li><li>向该实例地址发起远程调用</li></ul><p>问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</p><ul><li>user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳</li><li>当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service拉取服务时，就能将故障实例排除了</li></ul><blockquote><p>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端</p></blockquote><p>因此，接下来我们动手实践的步骤包括：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713220509769.png" alt="image-20210713220509769"></p><h2 id="3-2-搭建eureka-server"><a href="#3-2-搭建eureka-server" class="headerlink" title="3.2.搭建eureka-server"></a>3.2.搭建eureka-server</h2><p>首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务</p><h3 id="3-2-1-创建eureka-server服务"><a href="#3-2-1-创建eureka-server服务" class="headerlink" title="3.2.1.创建eureka-server服务"></a>3.2.1.创建eureka-server服务</h3><p>在cloud-demo父工程下，创建一个子模块：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713220605881.png" alt="image-20210713220605881"></p><p>填写模块信息：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713220857396.png" alt="image-20210713220857396"></p><p>然后填写服务信息：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713221339022.png" alt="image-20210713221339022"></p><h3 id="3-2-2-引入eureka依赖"><a href="#3-2-2-引入eureka依赖" class="headerlink" title="3.2.2.引入eureka依赖"></a>3.2.2.引入eureka依赖</h3><p>引入SpringCloud为eureka提供的starter依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-3-编写启动类"><a href="#3-2-3-编写启动类" class="headerlink" title="3.2.3.编写启动类"></a>3.2.3.编写启动类</h3><p>给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.eureka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-4-编写配置文件"><a href="#3-2-4-编写配置文件" class="headerlink" title="3.2.4.编写配置文件"></a>3.2.4.编写配置文件</h3><p>编写一个application.yml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> </span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h3 id="3-2-5-启动服务"><a href="#3-2-5-启动服务" class="headerlink" title="3.2.5.启动服务"></a>3.2.5.启动服务</h3><p>启动微服务，然后在浏览器访问：<a href="http://127.0.0.1:10086/">http://127.0.0.1:10086</a></p><p>看到下面结果应该是成功了：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713222157190.png" alt="image-20210713222157190"></p><h2 id="3-3-服务注册"><a href="#3-3-服务注册" class="headerlink" title="3.3.服务注册"></a>3.3.服务注册</h2><p>下面，我们将user-service注册到eureka-server中去。</p><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在user-service的pom文件中，引入下面的eureka-client依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）配置文件"><a href="#2）配置文件" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>在user-service中，修改application.yml文件，添加服务名称、eureka地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h3 id="3）启动多个user-service实例"><a href="#3）启动多个user-service实例" class="headerlink" title="3）启动多个user-service实例"></a>3）启动多个user-service实例</h3><p>为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。</p><p>首先，复制原来的user-service启动配置：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713222656562.png" alt="image-20210713222656562"></p><p>然后，在弹出的窗口中，填写信息：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713222757702.png" alt="image-20210713222757702"></p><p>现在，SpringBoot窗口会出现两个user-service启动配置：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713222841951.png" alt="image-20210713222841951"></p><p>不过，第一个是8081端口，第二个是8082端口。</p><p>启动两个user-service实例：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713223041491.png" alt="image-20210713223041491"></p><p>查看eureka-server管理页面：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713223150650.png" alt="image-20210713223150650"></p><h2 id="3-4-服务发现"><a href="#3-4-服务发现" class="headerlink" title="3.4.服务发现"></a>3.4.服务发现</h2><p>下面，我们将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。</p><h3 id="1）引入依赖-1"><a href="#1）引入依赖-1" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。</p><p>在order-service的pom文件中，引入下面的eureka-client依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）配置文件-1"><a href="#2）配置文件-1" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息：</p><p>在order-service中，修改application.yml文件，添加服务名称、eureka地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h3 id="3）服务拉取和负载均衡"><a href="#3）服务拉取和负载均衡" class="headerlink" title="3）服务拉取和负载均衡"></a>3）服务拉取和负载均衡</h3><p>最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。</p><p>不过这些动作不用我们去做，只需要添加一些注解即可。</p><p>在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713224049419.png" alt="image-20210713224049419"></p><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713224245731.png" alt="image-20210713224245731"></p><p>spring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。</p><h1 id="4-Ribbon负载均衡"><a href="#4-Ribbon负载均衡" class="headerlink" title="4.Ribbon负载均衡"></a>4.Ribbon负载均衡</h1><p>上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？</p><h2 id="4-1-负载均衡原理"><a href="#4-1-负载均衡原理" class="headerlink" title="4.1.负载均衡原理"></a>4.1.负载均衡原理</h2><p>SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713224517686.png" alt="image-20210713224517686"></p><p>那么我们发出的请求明明是<a href="http://userservice/user/1%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8F%98%E6%88%90%E4%BA%86http://localhost:8081%E7%9A%84%E5%91%A2%EF%BC%9F">http://userservice/user/1，怎么变成了http://localhost:8081的呢？</a></p><h2 id="4-2-源码跟踪"><a href="#4-2-源码跟踪" class="headerlink" title="4.2.源码跟踪"></a>4.2.源码跟踪</h2><p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p><p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p><p>我们进行源码跟踪：</p><h3 id="1）LoadBalancerIntercepor"><a href="#1）LoadBalancerIntercepor" class="headerlink" title="1）LoadBalancerIntercepor"></a>1）LoadBalancerIntercepor</h3><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/1525620483637.png" alt="1525620483637"></p><p>可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：获取请求uri，本例中就是 <a href="http://user-service/user/8">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id，<code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求。</li></ul><p>这里的<code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型，我们继续跟入。</p><h3 id="2）LoadBalancerClient"><a href="#2）LoadBalancerClient" class="headerlink" title="2）LoadBalancerClient"></a>2）LoadBalancerClient</h3><p>继续跟入execute方法：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/1525620787090.png" alt="1525620787090"></p><p>代码是这样的：</p><ul><li>getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。</li><li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</li></ul><p>放行后，再次访问并跟踪，发现获取的是8081：</p><p> <img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/1525620835911.png" alt="1525620835911"></p><p>果然实现了负载均衡。</p><h3 id="3）负载均衡策略IRule"><a href="#3）负载均衡策略IRule" class="headerlink" title="3）负载均衡策略IRule"></a>3）负载均衡策略IRule</h3><p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡:</p><p> <img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/1525620835911.png" alt="1525620835911"></p><p>我们继续跟入：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/1544361421671.png" alt="1544361421671"></p><p>继续跟踪源码chooseServer方法，发现这么一段代码：</p><p> <img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/1525622652849.png" alt="1525622652849"></p><p>我们看看这个rule是谁：</p><p> <img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/1525622699666.png" alt="1525622699666"></p><p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p><p> <img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/1525622754316.png" alt="1525622754316"></p><p>这不就是轮询的意思嘛。</p><p>到这里，整个负载均衡的流程我们就清楚了。</p><h3 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h3><p>SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713224724673.png" alt="image-20210713224724673"></p><p>基本流程如下：</p><ul><li>拦截我们的RestTemplate请求<a href="http://userservice/user/1">http://userservice/user/1</a></li><li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li><li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li><li>eureka返回列表，localhost:8081、localhost:8082</li><li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li><li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li></ul><h2 id="4-3-负载均衡策略"><a href="#4-3-负载均衡策略" class="headerlink" title="4.3.负载均衡策略"></a>4.3.负载均衡策略</h2><h3 id="4-3-1-负载均衡策略"><a href="#4-3-1-负载均衡策略" class="headerlink" title="4.3.1.负载均衡策略"></a>4.3.1.负载均衡策略</h3><p>负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713225653000.png" alt="image-20210713225653000"></p><p>不同规则的含义如下：</p><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</clientConfigNameSpace></clientName></td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong></td><td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><p>默认的实现就是ZoneAvoidanceRule，是一种轮询方案</p><h3 id="4-3-2-自定义负载均衡策略"><a href="#4-3-2-自定义负载均衡策略" class="headerlink" title="4.3.2.自定义负载均衡策略"></a>4.3.2.自定义负载均衡策略</h3><p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p><ol><li>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span> <span class="comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p></blockquote><h2 id="4-4-饥饿加载"><a href="#4-4-饥饿加载" class="headerlink" title="4.4.饥饿加载"></a>4.4.饥饿加载</h2><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span></span><br></pre></td></tr></table></figure><h1 id="5-Nacos注册中心"><a href="#5-Nacos注册中心" class="headerlink" title="5.Nacos注册中心"></a>5.Nacos注册中心</h1><p>国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。</p><h2 id="5-1-认识和安装Nacos"><a href="#5-1-认识和安装Nacos" class="headerlink" title="5.1.认识和安装Nacos"></a>5.1.认识和安装Nacos</h2><p><a href="https://nacos.io/">Nacos</a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud">SpringCloud</a>中的一个组件。相比<a href="https://github.com/Netflix/eureka">Eureka</a>功能更加丰富，在国内受欢迎程度较高。</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713230444308.png" alt="image-20210713230444308"></p><p>nacos启动命令，Windows命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd <span class="literal">-m</span> standalone</span><br></pre></td></tr></table></figure><h2 id="5-2-服务注册到nacos"><a href="#5-2-服务注册到nacos" class="headerlink" title="5.2.服务注册到nacos"></a>5.2.服务注册到nacos</h2><p>Nacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。</p><p>主要差异在于：</p><ul><li>依赖不同</li><li>服务地址不同</li></ul><h3 id="1）引入依赖-2"><a href="#1）引入依赖-2" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的依赖。</p></blockquote><h3 id="2）配置nacos地址"><a href="#2）配置nacos地址" class="headerlink" title="2）配置nacos地址"></a>2）配置nacos地址</h3><p>在user-service和order-service的application.yml中添加nacos地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的地址</p></blockquote><h3 id="3）重启"><a href="#3）重启" class="headerlink" title="3）重启"></a>3）重启</h3><p>重启微服务后，登录nacos管理页面，可以看到微服务信息：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713231439607.png" alt="image-20210713231439607"></p><h2 id="5-3-服务分级存储模型"><a href="#5-3-服务分级存储模型" class="headerlink" title="5.3.服务分级存储模型"></a>5.3.服务分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p><p>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713232522531.png" alt="image-20210713232522531"></p><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713232658928.png" alt="image-20210713232658928"></p><p>杭州机房内的order-service应该优先访问同机房的user-service。</p><h3 id="5-3-1-给user-service配置集群"><a href="#5-3-1-给user-service配置集群" class="headerlink" title="5.3.1.给user-service配置集群"></a>5.3.1.给user-service配置集群</h3><p>修改user-service的application.yml文件，添加集群配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><p>重启两个user-service实例后，我们可以在nacos控制台看到下面结果：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713232916215.png" alt="image-20210713232916215"></p><p>我们再次复制一个user-service启动配置，添加属性：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH</span><br></pre></td></tr></table></figure><p>配置如图所示：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713233528982.png" alt="image-20210713233528982"></p><p>启动UserApplication3后再次查看nacos控制台：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713233727923.png" alt="image-20210713233727923"></p><h3 id="5-3-2-同集群优先的负载均衡"><a href="#5-3-2-同集群优先的负载均衡" class="headerlink" title="5.3.2.同集群优先的负载均衡"></a>5.3.2.同集群优先的负载均衡</h3><p>默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p><p>因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p><p>1）给order-service配置集群信息</p><p>修改order-service的application.yml文件，添加集群配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:8848</span><br><span class="line">      discovery:</span><br><span class="line">        cluster-name: HZ <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><p>2）修改负载均衡规则</p><p>修改order-service的application.yml文件，修改负载均衡规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure><h2 id="5-4-权重配置"><a href="#5-4-权重配置" class="headerlink" title="5.4.权重配置"></a>5.4.权重配置</h2><p>实际部署中会出现这样的场景：</p><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p><p>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。</p><p>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713235133225.png" alt="image-20210713235133225"></p><p>在弹出的编辑窗口，修改权重：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210713235235219.png" alt="image-20210713235235219"></p><blockquote><p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</p></blockquote><h2 id="5-5-环境隔离"><a href="#5-5-环境隔离" class="headerlink" title="5.5.环境隔离"></a>5.5.环境隔离</h2><p>Nacos提供了namespace来实现环境隔离功能。</p><ul><li>nacos中可以有多个namespace</li><li>namespace下可以有group、service等</li><li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li></ul><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210714000101516.png" alt="image-20210714000101516"></p><h3 id="5-5-1-创建namespace"><a href="#5-5-1-创建namespace" class="headerlink" title="5.5.1.创建namespace"></a>5.5.1.创建namespace</h3><p>默认情况下，所有service、data、group都在同一个namespace，名为public：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210714000414781.png" alt="image-20210714000414781"></p><p>我们可以点击页面新增按钮，添加一个namespace：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210714000440143.png" alt="image-20210714000440143"></p><p>然后，填写表单：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210714000505928.png" alt="image-20210714000505928"></p><p>就能在页面看到一个新的namespace：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210714000522913.png" alt="image-20210714000522913"></p><h3 id="5-5-2-给微服务配置namespace"><a href="#5-5-2-给微服务配置namespace" class="headerlink" title="5.5.2.给微服务配置namespace"></a>5.5.2.给微服务配置namespace</h3><p>给微服务配置namespace只能通过修改配置来实现。</p><p>例如，修改order-service的application.yml文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="comment"># 命名空间，填ID</span></span><br></pre></td></tr></table></figure><p>重启order-service后，访问控制台，可以看到下面的结果：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210714000830703.png" alt="image-20210714000830703"></p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210714000837140.png" alt="image-20210714000837140"></p><p>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210714000941256.png" alt="image-20210714000941256"></p><h2 id="5-6-Nacos与Eureka的区别"><a href="#5-6-Nacos与Eureka的区别" class="headerlink" title="5.6.Nacos与Eureka的区别"></a>5.6.Nacos与Eureka的区别</h2><p>Nacos的服务实例分为两种l类型：</p><ul><li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p></li><li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><p>配置一个服务实例为永久实例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 设置为非临时实例</span></span><br></pre></td></tr></table></figure><p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p><p><img src="/2022/12/28/spring-cloud-%E5%AD%A6%E4%B9%A0/image-20210714001728017.png" alt="image-20210714001728017"></p><ul><li><p>Nacos与eureka的共同点</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li><p>Nacos与Eureka的区别</p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> Java </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始化</title>
      <link href="/2022/11/20/hello-hexo/"/>
      <url>/2022/11/20/hello-hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo基础使用"><a href="#Hexo基础使用" class="headerlink" title="Hexo基础使用"></a>Hexo基础使用</h2><span id="more"></span><h3 id="创建一个新帖子"><a href="#创建一个新帖子" class="headerlink" title="创建一个新帖子"></a>创建一个新帖子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>更多: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>更多: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>更多: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>更多: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
